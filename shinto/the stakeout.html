<!DOCTYPE HTML>
<!--
	Dimension by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>St. Petersburg Stakeout</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<div class="logo">
							<span class="icon fa-gem"></span>
						</div>
						<div class="content">
							<div class="inner">
								<h1>no te aproveches</h1>
								<p>de vez en cuando el enemigo te da ventaja en la carrera porque quiere jugar a la liebre y la tortuga, no te aproveches, usualmente es una trampa, esperalo a su proximo turno, no te saltes turnos, va a pica pala</p>
							</div>
						</div>
						<nav>
							<ul>
								<li><a href="#intro">St. Petersburg Stakeout</a></li>
<!--								<li><a href="#work">Work</a></li>
								<li><a href="#about">About</a></li>
								<li><a href="#contact">Contact</a></li>
								<li><a href="#intro">Intro</a></li>
								<li><a href="#work">Work</a></li>
								<li><a href="#about">About</a></li>
								<li><a href="#contact">Contact</a></li> -->
								<!--<li><a href="#elements">Elements</a></li>-->
							</ul>
							<!-- <ul><li><a href="#work">into the void</a></li></ul> -->
						</nav>
					</header>

				<!-- Main -->
					<div id="main">

						<!-- Intro -->
							<article id="intro">
								<h2 class="major">St. Petersburg Stakeout</h2>
								<span class="image main"><img src="images/pic01.jpg" alt="" /></span>
								<p>captura la bandera, re-f谩cil, bien podr铆a hacerlo yo mismo y publicarte los resultados pero eso, si, que seria un error, porque no puedo ignorarte asi nom谩s, 驴porque? f谩cil, porque hay cosas que tu desde donde estas ubicada est谩s observando y yo no, porque estoy en otra ubicaci贸n, asi pues lo que comparto aqu铆 son los algoritmos, un poco como los planos pero tu decides DONDE construirlos, para efectos de un ejemplo conciso, remplaza los titulos genericos con nombres espcificos en ocasiones pueden ser urls que siempre se deben expresar de la siguiente manera <pre><code>"/.urls/soyelfrailecarlitos.com"</code></pre>
								para el caso de que el sitio web del fraile carlitos represente una contravenci贸n agravada y escueta, por razones muy obvias tengo que explicarte que esto no tiene nada que ver con snocomm directamente, es mas bien como parte de DED en CONCORD. 驴que es CONCORD?
							</p>

							<h3>驴que es que?</h3>
							<p>CONCORD: es una organizaci贸n independiente fundada aproximadamente hace un siglo, se cre贸 para facilitar negociaciones entre diferentes razas para mejorar relaciones burocraticas, y motivar asi comercio y relaciones exteriores a traves del cobro de impuestos y disposici贸n policial interplanetaria (con ciertas excepciones porque CONCORD no protege ratas ni asesinos pero si, tiene presencia policial)</p>

							<p>Consolidated Cooperation and Relations Command (CONCORD)</p>
							<p>comenz贸 como un terreno neutral de reuniones y conferencias para diplom谩ticos y oficiales de diferentes procedencias, diferentes facciones, influyentes y de proporciones gigantescas conf铆an en CONCORD y poco a poco su influencia a aumentado y su poder tambi茅n. Se financia mediante proyectos personalizados, confiscar contrabando y trafico de especies ex贸ticas, y otras obligaciones.</p>

							<p>CONCORD cumple un rol neutral y por tanto todos los participantes de todas las grandes facciones discuten, debaten, denuncian y solucionan las circunstancias tan fr谩giles en las que se encuentra el tema interestelar. Las soluciones se obtienen a traves de documentaci贸n y compromisos so pena de multas por incumplimientos y otras clausulas. Se ha convertido en una instituci贸n independiente, y no ejerce bajo la influencia de ninguna facci贸n, influencia y confianza son dos cosas diferentes, ellos tienen permitido confiar pero no tienen permitido influir. Es bueno mantener las diferencias y que CONCORD sea independiente es una garant铆a de su neutralidad</p>

							<p>DED (directive Enforcement Department)</p>
							<p>DED es el "brazo policial fuertemente armado" de CONCORD, tiene como responsabilidad ubicar criminales y destruir instalaciones, recintos y edificaciones criminales que se encuentren porfuera de las fronteras de los espacios de alta seguridad, es la divisi贸n que se encarga de perseguir indefinidamente a trav茅s del espacio hasta destruir sus objetivos, es la divisi贸n a la cual se acude cuando ocurren actos de violencia o crimenes a manos de convoys, mas de 10 o 20 unidades enemigas o casos parecidos se reportan en DED para su destrucci贸n, no gestionan arrestos ni testigos o recolecci贸n de evidencias o negociaciones, es una divisi贸n puramente policial</p>

							<p>lo que hoy vamos a abordar es una denuncia que se realiz贸 a DED y que la divisi贸n CDIA (CONCORD Directive Intelligence Agency) se ofreci贸 a solucionar. como su nombre lo indic谩 CDIA ofrece y obtiene intel de situaciones, lugares, actitudes, facciones ilegales, anomal铆as y dem谩s. CDIA tiene personas que pueden interpretar, lo que hoy vamos a formular como posible respuesta a dicha denuncia, pueden interpretarlo de manera realista. es un ejercicio muy sencillo y puede probar ser 煤til apesar de tener un m茅todo gen茅rico, pues, lo gen茅rico se convierte en interesante a trav茅s de CDIA. si usted est谩 interesado en el stakeout y puede contribuir a continuaci贸n se delinean una referencia y posibles implementaciones sobre la primera de 15 denuncias presentadas en contra del 'demandado' cuyo nombre permanece secreto, porque la justicia a pesar de ser justa debe ser ciega.</p>

							<p>驴Que es una contravenci贸n?</p>
							<p>tiene una respuesta mucho mas elaborada en terminos de documentacion legal pero resumiendo un poco una contravenci贸n es toda actitud o obstrucci贸n que genere distorsi贸n al interior de un contexto cuyo origen no sea documentado como crimen. distorsionar las leyes con analog铆as, o reglamentaciones vagas que justifican cualquier atentado en contra del marco social democratico tiene, en varios casos prisi贸n por acto criminal. Si, algunas contravenciones pueden ser procesadas, no todas, pero si varias, la carta civil conocida como constitucion politica de la nacion es un documento escueto que parece mas una carta de iglesia. El caso del documento que define la ley penal militar y su forma de solucionar crimenes y sentencias est谩n, en contraste con la carta civil, basado en el derecho a la dignidad humana entre otras virtudes humanas desarrolladas mediante la discplina, el mutuo respeto, la mutua autoregulacion en casos de contrato o compromisos legales documentados que no vale la pena incluir en una carta de iglesia porque automaticamente todos se delcarar铆an pecadores y que son pecadores y punto, . Shimura los describiria diciendo "Cobardes que no tienen respeto por la palabra dada no merecen misericordia", para mi no merecen nada, ni trabajo, ni oportunidades porque las van a desaprovechar y desperdiciar tratando de ser pecadores. Decir mentiras en la corte es una contravenci贸n por afirmaciones falsas porque se tipifica que la calumnia tiene intencion delictiva. Para DED todas las denuncias que presenten antecedentes contravencionales tienen procedencia de orden legal en sentencias judiciales definitivas, la diferencia con otras instituciones policiales (la contravencion es un instrumento legal pero de uso policial), es que DED obtiene dicho intel en funci贸n de la destrucci贸n del objetivo, en funci贸n de motivar el desarrollo tecnol贸gico los extractores "octopus 8" de calibre 360, "kingzer", "Dia", "Luna" y similares est谩n permitidos en su uso durante operativos policiales, lo que ocurra con el lote de accesorios, items y dem谩s objetos que sobrevivan a las explosiones durante la destrucci贸n de la nave objetivo pierden propiedad y se consideran propiedad de quien las encuentre, se pueden vender y comerciar por creditos financieros de la divisa local en el territorio en el que se encuentre y no hay multa o sanci贸n. Pueden desaparecer debido a las explosiones o quedar incompletos por el enfrentamiento, por lo tanto si el enemigo las utiliza como evidencia, el argumento legal, es que una evidencia de inocencia no debe representar ante ninguna instancia de la justicia una norma penal vaga, a prop贸sito de evidencias malformadas o destruidas o deterioradas, porque incluyen elementos ambiguos, inciertos, o equ铆vocos sobre la inocencia de un presunto criminal denunciado ante DED. El hecho preterintencional no es redundante y puede ser condenado como preterintencional aun y cuando la evidencia sea escueta o vaga. En ocasiones se puede opinar sobre DED como una entidad que posee una actitud "arrogante, humillante, desp贸tica, caprichosa, extravagante y desafiante" pero dicha actitud est谩 presente en varios civiles que presentan antecedentes criminales y contravencionales, pero dichas actitudes no tienen carcel. por lo tanto se juzgan al interior de CONCORD como muestras deshonrosas y descargas deshonorables, pues, sea que se analicen las palabras en su sentido literal que justifica actividades criminales y deshonorosas en contra de poblaci贸n inocente considerada objetivos de guerra, o que se examine el contexto en el que se pronunciaron, los matices de vejamen que se encuentren en dicho modelo de comunicaci贸n sirven como evidencia de agresi贸n en contra de la honra o persona afectada, que por virtud criminal busca denunciar la sanci贸n policial en la cual las cuatro facciones depositaron su confianza hace un siglo. irrespetuosamente se puede destruir la honra y la salud mental de cualquiera, asi que por eso el tema respeto a la comunicaci贸n decente durante el juicio en una corte puede ser objeto de arresto y subsecuente interrupcion del juicio, dando prioridad a otro caso en el cual si se respete la oportunidad de demostrar la inocencia del demandado. La doctrina del hurto o doctrina que justifique actividad criminal se dialogar谩 en un juicio justo, en presencia del fiscal penal militar de garant铆as de turno, quien evaluar谩 el origen del caso y dentro de un tiempo limitado gestionar谩 los recursos posibles para garantizarle el derecho a un juicio justo, pero ningun oficial de CONCORD tiene la obligacion de divagar con excusas referentes a la carta civil y sus posibles injurias en contra de la tesis de aprehensi贸n ocurrida en circunstancias de delito.</p>

							<p>no es tanto el valor de los algoritmos que vamos a observar sino los recursos que la ley penal militar pone a disposici贸n de un caso cerrado como este, en cuyo caso es importante anotar que la l贸gica de programaci贸n contenida en este software no aplica para todos los contextos de denuncias a DED, pues, se alteraria el contexto y origen de la denuncia subyugando dicho contexto y dicho origen a la inpetitud causada por el abuso de autoridad tan deplorable que sufre el acusado, cuyo nombre permanece secreto por respeto a la justicia</p>

							<p>con secreto me refiero a que los algoritmos no sugieren nombres de variables ni de funciones, la justicia no sabe quienes son los implicados en la denuncia, a la justicia se le informa por medio de instrumentos y mecanismos que evidencian el origen de la denuncia, unos hechos, pero si usted considera que la historia es la misma y que los ineptos son los mismos que abusan de la autoridad que les da el poder que han gestionado, entonces aunque el contexto y origen de la denuncian han sido alterados y se han modificado, la sanci贸n que aplica DED es 煤til, como advertencia debo informarle que no todos los casos se dejan alterar y modificar para ello habr铆a que revisar denuncias en otros contextos y ver porqu茅 ser铆a una imprudencia modificar o alterar la instancia de contexto y origen</p>

							<h3>Algoritmos en orden de sucesiones:</h3>

							<p>Aqu铆 tienes un esquema de algoritmo en TCL que utiliza dos bucles `for` para funciones diferentes (watchdog con guardian y un francotirador) y dos bucles `for` para funciones id茅nticas (dos taxis que encubren el acto de corrupci贸n)</p>

							<h4>Descripci贸n del algoritmo</h4>
							<ol>
								<li>Primer `for` (funci贸n 1): Calcula una serie de n煤meros al cubo. (watchdog and guardian)</li>
								<li>Segundo `for` (funci贸n 2): Genera una serie de cadenas concatenadas. (francotirador)</li>
								<li>Tercer `for` (funciones id茅nticas): Realiza la misma tarea (sumar n煤meros) en un rango definido, pero la ejecuta dos veces con bucles separados. (dos taxis)</li>
							</ol>

							<p>recuerda que el c贸digo esta en formato gen茅rico, nombres como sum1 uno o sum2 deben ser reemplazados por valores de sistema que se encuentran en tu terminal de la siguiente forma</p>

							<pre><code>
man -k tcp
man -k ssh
							</code></pre>

							<p>etcetera donde el argumento para la opci贸n -k es el servicio que necesitas ubicar: (ssh, tcp, ftp, security, network, storage, error, protocol, son opciones comunes)</p>



<p>1. --- set and match ---
	<pre><code>

# Primer bucle: Calcula los cubos de n煤meros del 1 al 5 (watchdog and guardian)
puts "Resultados del primer bucle:"
for {set i 1} {$i <= 33} {incr i} {
    set cube [expr {$i * $i * $i}]
    puts "El cubo de $i es $cube"
}

# Segundo bucle: Genera una lista concatenando cadenas (francotirador)
puts "\nResultados del segundo bucle:"
set concatenated ""
for {set i 1} {$i <= 8} {incr i} {
    append concatenated "Elemento_$i "
}
puts "Cadena concatenada: $concatenated"

# Tercer y cuarto bucle: Suman n煤meros del 1 al 5 (funci贸n id茅ntica)
puts "\nResultados de los bucles id茅nticos:"
set sum1 0
for {set i 1} {$i <= 3} {incr i} {
    set sum1 [expr {$sum1 + $i}]
}
puts "La suma en el tercer bucle es: $sum1"

set sum2 0
for {set i 1} {$i <= 5} {incr i} {
    set sum2 [expr {$sum2 + $i}]
}
puts "La suma en el cuarto bucle es: $sum2"
</code></pre>


en los bucles for no debes alterar los siguientes valores:
<pre><code>
	{$i <= 33}
	{$i <= 8}
	{$i <= 2}
	{$i <= 3}
	{$i <= 5}
</code></pre>
pues dichos valores representan la arquitectura del dispositivo primario, se necesitan de ese tama帽o especifico cada uno.
</p>

<p>2. --- get the silver key ---</p>
<p><pre><code>
# Cargar la biblioteca tls
package require tls

# Lista de contrase帽as o tokens (CDIA Intel)
set expectedTokens [list "token1" "token2" "token3" "token4" "token5" \
                         "token6" "token7" "token8" "token9" "token10" "token11"]

# Inicializa el estado de autenticaci贸n
set authenticated 1  ;# 1 significa autenticado hasta que falle

puts "Iniciando autenticaci贸n: Se requieren 11 entradas correctas."

# Bucle de autenticaci贸n, mantener {$i < 11} intacto
for {set i 0} {$i < 11} {incr i} {
    # Simula una entrada del usuario (puedes reemplazar por gets stdin para entrada real)
    puts "Ingrese el token para la posici贸n [expr {$i + 1}]:"
    gets stdin userInput ;# "userInput" puede ser remplazada con valores propios

    # Compara la entrada del usuario con el token esperado
    if { $userInput != [lindex $expectedTokens $i] } {
        puts "Autenticaci贸n fallida en la posici贸n [expr {$i + 1}]."
        set authenticated 0  ;# establece la autenticaci贸n como "no autenticado"
        break
    }
}

# Si la autenticaci贸n es exitosa, inicia el servicio TCP/TLS
if {$authenticated} {
    puts "Autenticaci贸n exitosa. Iniciando servicio TLS en el puerto 8080..."

    # Configuraci贸n de los certificados y claves
    set certFile "server-cert.pem"   ;# Ruta al certificado del servidor (/.urls/etc...)
    set keyFile "server-key.pem"     ;# Ruta a la clave privada del servidor (/.urls/etc...)

    # Funci贸n para manejar conexiones TLS
    proc handleTLSConnection {sock addr port} {
        puts "Nueva conexi贸n segura desde $addr:$port"

        # Hacer la conexi贸n TLS segura
        tls::import $sock
        puts $sock "Bienvenido al servicio seguro TLS. Escribe un mensaje:"
        flush $sock

        # Lee datos del cliente y responde
        fileevent $sock readable [list readTLSData $sock]
    }

    # Funci贸n para leer datos del cliente en TLS
    proc readTLSData {sock} {
        if {[eof $sock]} {
            close $sock
            puts "Conexi贸n cerrada."
            return
        }
        set data [gets $sock]
        puts "Cliente dice: $data"
        puts $sock "Mensaje recibido de forma segura: $data"
        flush $sock
    }

    # Inicia el servidor seguro TLS
    set server [socket -server handleTLSConnection 8080]
    tls::server configure -certfile $certFile -keyfile $keyFile
    puts "Servicio TLS escuchando en el puerto 8080. Presione Ctrl+C para salir."
    vwait forever  ;# Mant茅n el servidor ejecut谩ndose
} else {
    puts "Autenticaci贸n denegada. Intente de nuevo."
}
</code></pre></p>


<p>Explicaci贸n de TLS:</p>
<ol>Certificados y claves:
   <li> Necesitas un archivo de certificado (`server-cert.pem`) y un archivo de clave privada (`server-key.pem`).</li>
   <li> Puedes generar estos archivos utilizando `openssl`. Por ejemplo, al interior de un nuevo documento titulado server-key.sh puedes crearlo:</li>
   <pre><code>
openssl req -x509 -newkey rsa:2048 -keyout server-key.pem -out server-cert.pem -days 365 -nodes
   </code></pre>
   <p>Importaci贸n de TLS:</p>
   <li>Cuando un cliente se conecta, el servidor convierte el socket est谩ndar en un socket TLS con `tls::import`.</li>
   <p></p>
   <p>Seguridad:</p>
   <li>Los datos intercambiados entre el cliente y el servidor est谩n encriptados. Esto asegura que la comunicaci贸n no pueda ser interceptada f谩cilmente.</li>

</ol>

<p>Prueba del servidor:</p>
<li>Usa herramientas compatibles con TLS, como `openssl s_client` en un archivo de texto de extensi贸n .zsh:</li>
<pre><code>
openssl s_client -connect localhost:8080	
</code></pre>

<p>Aqu铆 tienes un cliente TCL que se conecta de forma segura al servidor TLS creado anteriormente. Este cliente utiliza el paquete `tls` para realizar la conexi贸n.</p>

<pre><code>
# Cargar la biblioteca tls
package require tls

# Direcci贸n y puerto del servidor
set serverAddress "localhost"  ;# Cambia a la direcci贸n IP o nombre del servidor
set serverPort 8080

# Ruta al archivo de certificado de confianza (si es necesario validar el servidor)
# Puedes usar un certificado auto-firmado o el del servidor
set caFile "server-cert.pem"

# Establecer una conexi贸n segura al servidor TLS
puts "Conectando de forma segura al servidor en $serverAddress:$serverPort..."
set sock [tls::socket $serverAddress $serverPort -cafile $caFile]

# Verificar la conexi贸n
if {[catch {gets $sock welcomeMessage} err]} {
    puts "Error en la conexi贸n: $err"
    exit 1
} else {
    puts "Conexi贸n exitosa: $welcomeMessage"
}

# Interactuar con el servidor (implementaci贸n generica, podrias enviar comandos encontrados con man -k al servidor)
# tambien puedes encontrar el gestor de se帽al a traves del siguiente comando en tu terminal:
# man kill
# debiera listarte las mas comunes: hung up, interrupt, quit, abort, kill, alrm, term


puts "Escriba un mensaje para enviar al servidor (escriba 'exit' para salir):"

while {1} {
    puts -nonewline "Mensaje: "
    flush stdout
    gets stdin userInput

    if {$userInput eq "exit"} {
    	# envia comandos aqui
        puts "Cerrando conexi贸n..."
        close $sock
        exit 0
    }

    # Enviar mensaje al servidor
    # mas comandos aqui
    puts $sock $userInput
    flush $sock

    # Leer respuesta del servidor
    if {[catch {gets $sock serverResponse} err]} {
        puts "Error al recibir respuesta: $err"
        close $sock
        exit 1
    } else {
        puts "Respuesta del servidor: $serverResponse"
    }
}

</code></pre>

<p>Explicaci贸n del Cliente:</p>
<ol>

	<li>Conexi贸n TLS:</li>
<ul> 
	<li>Usa `tls::socket` para conectarse al servidor de forma segura.</li>
	<li>`-cafile` permite validar el certificado del servidor. Si el servidor tiene un certificado auto-firmado, usa el mismo archivo que generaste (`server-cert.pem`).</li>
</ul>


	<li>Interacci贸n con el servidor:</li>
<ul> 
	<li>El cliente env铆a mensajes al servidor y lee las respuestas en un bucle.</li>
	<li>`Escribe "exit" para cerrar la conexi贸n.</li>
</ul>


	<li>Manejo de errores:</li>
<ul> 
	<li>Si hay problemas durante la conexi贸n o la comunicaci贸n, el programa mostrar谩 un mensaje y saldr谩.</li>
</ul>

<p>recuerda ingresar mensajes en el cliente para interactuar con las respuestas del servidor.</p>


</ol>

<p>3 --- activar el watchdog con guardian ---</p>
<p>Aqu铆 tienes un ejemplo de un algoritmo que utiliza un bucle `for` para iterar 6 veces sobre un diccionario en TCL, ejecutando dos funciones diferentes en cada iteraci贸n:</p>



<p>Algoritmo:</p>
<ol>
<li> Define un diccionario con al menos 6 pares clave-valor.</li>
<li>Usa un bucle `for` para iterar exactamente 6 veces.</li>
<li>En cada iteraci贸n:<ul>
   <li>Llama a la primera funci贸n, que procesa la clave.</li>
   <li>Llama a la segunda funci贸n, que procesa el valor.</li>
</ul></li>
<li>Muestra los resultados.</li>
</ol>

<pre><code>
# Definir el diccionario
set myDict {
    "clave1" "valor1"
    "clave2" "valor2"
    "clave3" "valor3"
    "clave4" "valor4"
    "clave5" "valor5"
    "clave6" "valor6"
}

# Definir la primera funci贸n: procesa la clave
proc processKey {key} {
    puts "Procesando clave: $key"
    # Agrega l贸gica personalizada aqu铆:
    # clausulas if, declaracion de variables o constantes
    # listas, comandos, bucles for etc...

    # una forma interesante de incrustar lenguajes de programaci贸n 
    # que no sean tcl dentro de un script tcl
    # es con la siguiente sint谩xis:
    	# par茅ntesis, forward slash, extension del lenguaje de programacion
    	# ejemplo:
    			# nombreDeLaFuncion(/.py) {
 			#   from math import *
 			#	# python code here
 			# }

# la funcion tiene parentesis y corchetes
# como todas las funciones en C, 
# y adentro va el programa que vas a incrustar

    return "Clave procesada: $key"
}

# Definir la segunda funci贸n: procesa el valor
proc processValue {value} {
    puts "Procesando valor: $value"
    # Agrega l贸gica personalizada aqu铆
    return "Valor procesado: $value"
}

# Iterar sobre el diccionario
puts "Iterando sobre el diccionario..."
set keys [dict keys $myDict]
for {set i 0} {$i < 6} {incr i} {
    set key [lindex $keys $i]
    set value [dict get $myDict $key]

    # Llamar a la primera funci贸n con la clave
    set processedKey [processKey $key]

    # Llamar a la segunda funci贸n con el valor
    set processedValue [processValue $value]

    # Mostrar resultados
    puts "Resultado clave: $processedKey"
    puts "Resultado valor: $processedValue"
    puts "--------------------------------"
}

</code></pre>

<p>Explicaci贸n del C贸digo:</p>
<ol>
	<li>Diccionario: 
		<ul>
			<li>`myDict` contiene 6 pares clave-valor que ser谩n iterados.</li>
		</ul>
	</li>
	<li>Funciones: 
		<ul>
			<li>`processKey` recibe una clave y realiza una acci贸n (en este caso, solo imprime y retorna un mensaje procesado).</li>
			<li>`processValue` hace lo mismo pero con un valor.</li>
		</ul>
	</li>
		<li>Bucle `for: 
		<ul>
			<li>Itera exactamente 6 veces (铆ndices de 0 a 5).</li>
			<li>Usa `dict keys` para obtener todas las claves del diccionario y `dict get` para obtener los valores correspondientes.</li>
		</ul>
	</li>
	<li>Resultados: 
		<ul>
			<li>En cada iteraci贸n, se procesan la clave y el valor con sus respectivas funciones.</li>
			<li>Los resultados se imprimen.</li>
		</ul>
	</li>

</ol>

<p>Salida Ejemplo:</p>
<pre><code>
Iterando sobre el diccionario...
Procesando clave: clave1
Procesando valor: valor1
Resultado clave: Clave procesada: clave1
Resultado valor: Valor procesado: valor1
--------------------------------
Procesando clave: clave2
Procesando valor: valor2
Resultado clave: Clave procesada: clave2
Resultado valor: Valor procesado: valor2
--------------------------------

</code></pre>

<p>4. --- acceso a la ubicaci贸n del francotirador (SIGKILL source on their side) ---</p>
<p>Algoritmo:</p>
<ol>
	<li>Definir 9 variables booleanas con el valor `true`.</li>
	<li>Usar un bucle `for` para iterar sobre las 9 variables.</li>
	<li>Verificar que todas las variables sean `true` durante cada iteraci贸n.</li>
	<li>Si todas las variables son `true` al finalizar el bucle, se autoriza el uso de servicios de red mediante UDP.</li>
</ol>

	<p>CUIDADO! en este algoritmo es imperativo no alterar la cantidad de variables en el paso 1, es imperativo mantener la logica basada en movimiento atrav茅s de bucles for, verificar y conceder acceso autorizado para evitar que el sistema te rechace o te ignore de imprevisto</p>

<pre><code>
# Definir 9 variables booleanas con valor true
set var1 true
set var2 true
set var3 true
set var4 true
set var5 true
set var6 true
set var7 true
set var8 true
set var9 true

# Lista de variables booleanas
set vars {var1 var2 var3 var4 var5 var6 var7 var8 var9}

# Inicializa el estado de autorizaci贸n
set authorized 1  ;# 1 significa autorizado, 0 denegado

# Iterar sobre las 9 variables booleanas
for {set i 0} {$i < 9} {incr i} {
    set currentVar [lindex $vars $i]
    
    # Verificar si la variable actual es false
    if {![set $currentVar]} {
        set authorized 0  ;# Denegar autorizaci贸n si alguna variable es false
        break
    }
}

# Si todas las variables son true, autorizar el uso de UDP
if {$authorized} {
    puts "Todas las variables son TRUE. Autorizando uso de servicios de red con UDP..."
    
    # Configurar el servicio de red UDP
    set udpPort 12345  ;# El puerto para los datagramas UDP
    set serverAddr "localhost"  ;# Direcci贸n del servidor UDP

    # Crear socket UDP
    set sock [socket -type udp $serverAddr $udpPort]
    if {$sock != ""} {
        puts "Socket UDP creado en $serverAddr:$udpPort"
        # Enviar un mensaje a trav茅s del socket UDP
        puts $sock "Mensaje de prueba a trav茅s de UDP"
        flush $sock
        close $sock
        puts "Mensaje enviado a trav茅s de UDP y conexi贸n cerrada."
    } else {
        puts "Error al crear el socket UDP."
    }
} else {
    puts "Autorizaci贸n fallida. No se puede acceder a los servicios de red."
}
</code></pre>

<p>Salida de ejemplo</p>
<p>Si todas las variables son `true`, la salida ser谩 algo como:</p>
<pre><code>
Todas las variables son TRUE. Autorizando uso de servicios de red con UDP...
Socket UDP creado en localhost:12345
Mensaje enviado a trav茅s de UDP y conexi贸n cerrada.

</code></pre>

<p>Si alguna variable es `false`, la salida ser谩:</p>
<pre>
	<code>Autorizaci贸n fallida. No se puede acceder a los servicios de red.</code>
</pre>

<p>ejemplo de ruteo sobre capa 2 del modelo osi sin switch, solo con hub  utilizado en kotlin (kotlin es el lenguaje de programaci贸n que utiliza el demandado)</p>
<pre>
	<code>
#[cfg(test)]
mod tests {
	#[test]
	fn it_works() {
		let result = 2 + 2;
		assert_eq!(result, 4);
	}
}
</code>
</pre>



<p>el cual es reemplazado por programaci贸n funcional al interior de bucles for para mayor precisi贸n y depuraci贸n por fases.
</p>

<p>5. --- interacci贸n con el francotirador ---</p>
<p>Para implementar una sesi贸n remota segura a trav茅s de SSH en TCL, puedes usar la biblioteca `ssh` de TCL, que proporciona la funcionalidad necesaria para interactuar con servidores a trav茅s de SSH. 
Desafortunadamente, TCL no incluye un paquete de SSH por defecto, pero se puede usar un paquete como `Tcllib` o `ssh2` para establecer una conexi贸n SSH.

A continuaci贸n, te proporcionar茅 un ejemplo de c贸mo podr铆as escribir un algoritmo en TCL para iniciar sesi贸n en tu servidor remoto a trav茅s de TCP utilizando SSH</p>

<p>Algoritmo:</p>
<ol>
	<li>Establecer la direcci贸n del servidor y el puerto SSH (generalmente el puerto 22).</li>
	<li>Proporcionar las credenciales del usuario (nombre de usuario y contrase帽a).</li>
	<li>Utilizar la biblioteca SSH para establecer una conexi贸n segura.</li>
	<li>Ejecutar comandos remotos en el servidor.</li>
</ol>

<p>El c贸digo en TCL es utilizando `ssh2` (que es un paquete com煤n de SSH en TCL):</p>

<pre>
	<code>
# Cargar la biblioteca de ssh2 (aseg煤rate de tenerla instalada)
package require ssh2

# Direcci贸n y puerto del servidor SSH
set serverAddress "your.server.com"  ;# Cambia por la direcci贸n del servidor del fraile carlitos
set serverPort 22

# Credenciales del usuario
set username "yourUsername"         ;# Cambia por el nombre de usuario del fraile carlitos
set password "yourPassword"         ;# Cambia por la contrase帽a del fraile carlitos

# Crear una conexi贸n SSH con autenticaci贸n por clave privada
set privateKeyFile "/path/to/private/key"
set sshChannel [ssh2::connect $serverAddress -port $serverPort -username $username -identityfile $privateKeyFile]

# Verificar la conexi贸n
if {![info exists sshChannel]} {
    puts "Error al conectar al servidor SSH."
    exit 1
} else {
    puts "Conexi贸n SSH establecida exitosamente."

# Ejecutar un comando remoto (por ejemplo, 'ls' para listar los archivos)
# o por ejemplo man -k etc...
set command "ls -l"
set result [ssh2::exec $sshChannel $command]

# Mostrar el resultado del comando
puts "Resultado del comando '$command':"
puts $result

# Cerrar la conexi贸n SSH
ssh2::disconnect $sshChannel
puts "Conexi贸n SSH cerrada."

	</code>
</pre>


<p>6. --- asesinar al francotirador y reportar su muerte ---</p>
<p>Este c贸digo simula una conexi贸n UDP, maneja errores de conectividad, y genera un log si el proceso termina de manera abrupta (simulando `SIGKILL` usando una terminaci贸n controlada o un error). pero tu podrias implementar --kill -s SIGKILL-- en la instancia que corresponda</p>

<pre><code>

package require Tcl 8.6

# Configuraci贸n de par谩metros de la conexi贸n UDP
set serverAddress "localhost"
set serverPort 12345

# Inicializar log de errores
set logFile "error_log.txt"

# Funci贸n para registrar el error
proc log_error {message} {
    global logFile
    set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
    set logMessage "$timestamp - ERROR: $message"
    
    # Escribir en el archivo de log
    set fileId [open $logFile "a"]
    puts $fileId $logMessage
    close $fileId
    puts $logMessage  ;# Mostrar el error en la consola tambi茅n
}

# Funci贸n para manejar el SIGTERM (simulando un error de conectividad que dispara el SIGKILL)
proc handle_SIGTERM {} {
    log_error "El proceso fue terminado inesperadamente debido a un error en la conectividad de UDP."
    exit 1
}

# Manejo de SIGTERM (similar a un error cr铆tico que dispara la terminaci贸n del proceso)
trap handle_SIGTERM SIGTERM

# Funci贸n para simular la conexi贸n UDP
proc udp_connect {} {
    global serverAddress serverPort

    # Intentar crear el socket UDP
    set sock [socket -type udp $serverAddress $serverPort]
    if {$sock == ""} {
        log_error "Error al crear el socket UDP para $serverAddress:$serverPort."
        exit 1
    }
    puts "Conexi贸n UDP establecida con $serverAddress:$serverPort."

    # Simular un error de conectividad (por ejemplo, el servidor no responde)
    set data "Mensaje de prueba"
    catch {
        puts $sock $data
        flush $sock
    } result

    # Si ocurre un error en el env铆o, loguearlo y simular un fallo
    if {[string length $result] > 0} {
        log_error "Error en la transmisi贸n UDP: $result"
        close $sock
        exit 1
    }

    # Cerrar la conexi贸n correctamente
    close $sock
    puts "Mensaje enviado exitosamente a trav茅s de UDP."
}

# Simular un error de conectividad despu茅s de un tiempo
after 5000 {
    udp_connect
}

# Simular un error que puede disparar un SIGKILL (como un fallo en el servidor)
after 10000 {
    # Simulamos que el servidor dej贸 de responder o alguna otra raz贸n que cause un fallo cr铆tico
    log_error "El servidor no respondi贸 a tiempo, simulando un SIGKILL en el proceso."
    exit 1
}

# Mantener el script en ejecuci贸n para observar los eventos
vwait forever
</code></pre>

<p>Explicaci贸n del c贸digo</p>
<ol>
	<li>Log de errores:
		<ul>
			<li>Se crea una funci贸n `log_error` que recibe un mensaje y lo registra tanto en la consola como en un archivo de log (`error_log.txt`). Tambi茅n incluye un timestamp para saber cu谩ndo ocurri贸 el error.</li>
		</ul>
	</li>
	<li>Simulaci贸n de Conexi贸n UDP:
		<ul>
			<li>La funci贸n `udp_connect` simula la creaci贸n de una conexi贸n UDP a un servidor. Si no puede establecer el socket o hay un error durante la transmisi贸n de datos, se genera un mensaje de error, se 
registra en el log, y el proceso termina con `exit 1`.</li>
		</ul>
	</li>
	<li>Manejo de Se帽ales:
		<ul>
			<li>La funci贸n `handle_SIGTERM` es una simulaci贸n para manejar un "error fatal" que podr铆a disparar el comportamiento similar a un `SIGKILL`. En este caso, se genera un error y se registra en el log 
antes de cerrar el proceso.</li>
		</ul>
	</li>
	<li>Simulaci贸n de Error de Conectividad:
		<ul>
			<li>Despu茅s de un retraso de 5 segundos (`after 5000`), se intenta conectar a trav茅s de UDP.</li>
			<li>A los 10 segundos (`after 10000`), simula un fallo en la conectividad (como si el servidor dejara de responder), lo que resulta en un registro de error y termina el proceso.</li>
		</ul>
	</li>
	<li>Simulaci贸n de Terminado Abrupto:
		<ul>
			<li>Aunque no podemos capturar `SIGKILL` directamente en Tcl, la funci贸n `handle_SIGTERM` se usa para simular c贸mo el proceso manejar铆a un fallo de conectividad o terminaci贸n abrupta y c贸mo registrar 
ese evento en un log.</li>
		</ul>
	</li>

</ol>

<p>Salida Ejemplo:</p>
<p>Si el servidor no responde o si ocurre un error, el archivo de log (`error_log.txt`) podr铆a contener una entrada similar a esta:</p>
<pre><code>
2024-12-29 12:34:56 - ERROR: Error al crear el socket UDP para localhost:12345.
2024-12-29 12:34:56 - ERROR: El proceso fue terminado inesperadamente debido a un error en la conectividad de UDP.
</code></pre>

<p>Si el servidor responde correctamente, se loguea un mensaje de 茅xito:</p>
<pre><code>
2024-12-29 12:34:56 - ERROR: El servidor no respondi贸 a tiempo, simulando un SIGKILL en el proceso.
</code></pre>


<h4>oh yes, back a step</h4>
<p>7. --- kill the watchdog and it's guardian ---</p>
<p>En TCL, no existe una forma directa o expl铆cita para "desinicializar" una variable como en otros lenguajes de programaci贸n (por ejemplo, con `null` o `delete`). Sin embargo, puedes lograr un 
comportamiento similar a la desinicializaci贸n utilizando ciertas estrategias para "limpiar" las variables o "eliminarlas" al final de un bucle `for`. Hay varias formas en las que puedes manejar esto 
dependiendo del tipo de variables y del flujo de tu programa.

<p>Voy a mostrarte un ejemplo con un bucle `for` que itera sobre 6 variables, cada una asociada a una funci贸n, y c贸mo podr铆as "limpiar" esas variables despu茅s de las iteraciones.</p>
</p>

<p>Este ejemplo tiene 6 variables y 6 funciones que se ejecutan durante 6 iteraciones. Despu茅s de las iteraciones, las variables se "limpian" (por ejemplo, elimin谩ndolas con `unset` o asign谩ndoles valores 
nulos).</p>

<p>recuerda mantener intactas las cantidades para variables y el contador del bucle for</p>

<pre><code>
# Definir funciones que se ejecutar谩n dentro del bucle
proc func1 {var} {
    puts "Ejecutando func1 con $var"
}

proc func2 {var} {
    puts "Ejecutando func2 con $var"
}

proc func3 {var} {
    puts "Ejecutando func3 con $var"
}

proc func4 {var} {
    puts "Ejecutando func4 con $var"
}

proc func5 {var} {
    puts "Ejecutando func5 con $var"
}

proc func6 {var} {
    puts "Ejecutando func6 con $var"
}

# Iniciar un bucle for de 6 iteraciones
for {set i 1} {$i <= 6} {incr i} {
    # Crear las variables dentro del bucle
    set var$i "Valor de var$i"
    
    # Ejecutar las funciones dependiendo de la iteraci贸n
    switch $i {
        1 {func1 $var1}
        2 {func2 $var2}
        3 {func3 $var3}
        4 {func4 $var4}
        5 {func5 $var5}
        6 {func6 $var6}
    }
    
    # Limpiar (desinicializar) las variables
    unset var$i
}

# Verificar que las variables fueron desinicializadas
puts "Las variables var1 a var6 han sido desinicializadas."
</code></pre>

<p>Explicaci贸n del c贸digo</p>
<ol>
	<li> Funciones:
		<ul>
			<li>Se definen 6 funciones, `func1` a `func6`, que reciben un par谩metro y simplemente imprimen un mensaje para indicar qu茅 funci贸n se ejecut贸.</li>
		</ul>
	</li>
	<li> Bucle `for`:
		<ul>
			<li>El bucle `for` itera 6 veces, desde `i = 1` hasta `i = 6`.</li>
			<li>En cada iteraci贸n, se crea una variable `var$i` (por ejemplo, `var1`, `var2`, etc.) y se le asigna un valor.</li>
			<li>Luego, dependiendo de la iteraci贸n (`i`), se ejecuta la funci贸n correspondiente (`func1` a `func6`) pasando la variable creada.</li>
		</ul>
	</li>
	<li> Desinicializaci贸n:
		<ul>
			<li>Despu茅s de cada iteraci贸n, utilizamos `unset var$i` para eliminar la variable creada en esa iteraci贸n. Esto simula la "desinicializaci贸n" de las variables.</li>
			<li>La funci贸n `unset` elimina la variable de la memoria, por lo que ya no est谩 disponible despu茅s de su eliminaci贸n.</li>
		</ul>
	</li>
	<li> Verificaci贸n:
		<ul>
			<li>Al final, se imprime un mensaje indicando que las variables `var1` a `var6` han sido desinicializadas.</li>
		</ul>
	</li>
</ol>

<p>Salida esperada:</p>
<pre>
	<code>
Ejecutando func1 con Valor de var1
Ejecutando func2 con Valor de var2
Ejecutando func3 con Valor de var3
Ejecutando func4 con Valor de var4
Ejecutando func5 con Valor de var5
Ejecutando func6 con Valor de var6
Las variables var1 a var6 han sido desinicializadas.

	</code>
</pre>

<ul>
	<li>Notas importantes:
		<ul>
			<li>`unset`: El comando `unset` es utilizado para eliminar una variable en TCL. Esto efectivamente "desinicializa" la variable y la elimina del entorno.</li>
			<li>mbito de las variables:** Si las variables est谩n dentro del 谩mbito del bucle (es decir, son creadas dentro del bucle), `unset` las elimina despu茅s de que se haya terminado su uso.</li>
		</ul>
		<p>Este enfoque garantiza que las variables sean "limpiadas" al finalizar su uso, simulando la desinicializaci贸n</p>
	</li>
</ul>




<p>8. --- encontrar los dos taxis ---</p>

<p>Para implementar un algoritmo en Tcl que itere una vez sobre cada uno de los 7 diccionarios en un bucle `for`, puedes estructurarlo de la siguiente manera:
<ol>
<li>Definir los diccionarios:** Crear 7 diccionarios con claves y valores.</li>
<li>Iterar sobre los diccionarios:** Usar un bucle `for` para iterar sobre los diccionarios.</li>
<li>Acceder a cada diccionario:** Acceder a cada clave y valor dentro de cada diccionario durante cada iteraci贸n.</li>
</ol>
</p>

<pre>
	<code>
# Definir 7 diccionarios con algunas claves y valores
set dict1 {a 1 b 2 c 3}
set dict2 {x 10 y 20 z 30}
set dict3 {name John age 30 city NY}
set dict4 {fruit apple color red}
set dict5 {country USA population 330M currency USD}
set dict6 {book title author "John Doe"}
set dict7 {animal lion habitat jungle}

# Lista de diccionarios a iterar
set dictionaries [list dict1 dict2 dict3 dict4 dict5 dict6 dict7]

# Bucle for que itera una vez sobre cada diccionario
foreach dictName $dictionaries {
    # Obtener el diccionario actual
    set currentDict [set $dictName]
    
    # Iterar sobre las claves y valores del diccionario actual
    foreach {key value} $currentDict {
        # Mostrar cada clave y valor del diccionario
        puts "En el diccionario $dictName, la clave es '$key' y el valor es '$value'."
    }
}
	</code>
</pre>


<p>Explicaci贸n del c贸digo:</p>
<ol>
	<li> Definir Diccionarios::
		<ul>
			<li>Se crean 7 diccionarios con diferentes pares clave-valor. Por ejemplo, `dict1` tiene las claves `a`, `b` y `c` con los valores correspondientes.</li>
		</ul>
	</li>
<li> Lista de Diccionarios::
		<ul>
			<li>Se crea una lista `dictionaries` que contiene los nombres de los 7 diccionarios. Esta lista es utilizada por el bucle `foreach` para iterar a trav茅s de cada diccionario.</li>
		</ul>
	</li>
<li> Bucle `foreach`::
		<ul>
			<li>El bucle `foreach` itera una vez sobre cada diccionario. Durante cada iteraci贸n, se obtiene el contenido del diccionario actual (`currentDict`), que es el valor de la variable de diccionario.</li>
		</ul>
	</li>
<li> Iteraci贸n sobre las Claves y Valores::
		<ul>
			<li>Dentro de cada diccionario, se usa otro `foreach` para iterar sobre las claves y los valores del diccionario, y se imprime cada par de clave-valor.</li>
		</ul>
	</li>
</ol>

<p>Salida esperada o mejor, salida tropical o mejor salida tipica, ahi estamos pintados:</p>
<pre>
	<code>
En el diccionario dict1, la clave es 'a' y el valor es '1'.
En el diccionario dict1, la clave es 'b' y el valor es '2'.
En el diccionario dict1, la clave es 'c' y el valor es '3'.
En el diccionario dict2, la clave es 'x' y el valor es '10'.
En el diccionario dict2, la clave es 'y' y el valor es '20'.
En el diccionario dict2, la clave es 'z' y el valor es '30'.
En el diccionario dict3, la clave es 'name' y el valor es 'John'.
En el diccionario dict3, la clave es 'age' y el valor es '30'.
En el diccionario dict3, la clave es 'city' y el valor es 'NY'.
En el diccionario dict4, la clave es 'fruit' y el valor es 'apple'.
En el diccionario dict4, la clave es 'color' y el valor es 'red'.
En el diccionario dict5, la clave es 'country' y el valor es 'USA'.
En el diccionario dict5, la clave es 'population' y el valor es '330M'.
En el diccionario dict5, la clave es 'currency' y el valor es 'USD'.
En el diccionario dict6, la clave es 'book' y el valor es 'title'.
En el diccionario dict6, la clave es 'author' y el valor es 'John Doe'.
En el diccionario dict7, la clave es 'animal' y el valor es 'lion'.
En el diccionario dict7, la clave es 'habitat' y el valor es 'jungle'.

	</code>
</pre>

<p>Explicaci贸n de la l贸gica:</p>
<ul>
	<li>Lista de Diccionarios:** Usamos `set dictionaries [list dict1 dict2 dict3 dict4 dict5 dict6 dict7]` para crear una lista con los nombres de los diccionarios. Esta lista ser谩 usada en el primer bucle 
`foreach` para acceder a cada diccionario de forma secuencial.</li>
	<li>Acceso a Diccionarios: El comando `set currentDict [set $dictName]` obtiene el contenido del diccionario asociado a la variable `dictName` durante cada iteraci贸n.</li>
	<li>Iteraci贸n Interna: Dentro de cada diccionario, usamos `foreach {key value} $currentDict` para iterar sobre las claves y valores, y mostrar el contenido.</li>
</ul>



<p>9. --- kill the first taxi ---</p>
<p>Advertencia: no cambiar las cantidades de los contadores por nada del mundo, por favor </p>
<pre><code>
# Tercer y cuarto bucle: Suman n煤meros del 1 al 5 (funci贸n id茅ntica)
puts "\nResultados de los bucles id茅nticos:"
set sum1 0
for {set i 1} {$i <= 3} {incr i} {
    set sum1 [expr {$sum1 + $i}]
}

puts "La suma en el tercer bucle es: $sum1"

# Verificar si la suma es igual a 2
if {$sum1 == 2} {
    puts "Se ha alcanzado la suma 2. Simulando SIGKILL..."
    
    # aniquila el proceso del taxi
    kill -s SIGKILL $sum1
}


</code></pre>


<p>10. --- kill the second taxi ---</p>
<p>lo mismo, las cuentas de las cantidades son vitales, baby, no las cambies por nada por favor:</p>

<pre><code>

# Tercer y cuarto bucle: Suman n煤meros del 1 al 5 (funci贸n id茅ntica)
puts "\nResultados de los bucles id茅nticos:"
set sum2 0
for {set i 1} {$i <= 5} {incr i} {
    set sum2 [expr {$sum1 + $i}]
}

puts "La suma en el tercer bucle es: $sum2"

# Verificar si la suma es igual a 3
if {$sum2 == 3} {
    puts "Se ha alcanzado la suma 2. Simulando SIGKILL..."

    # aniquila el proceso del taxi
    kill -s SIGKILL $sum2
}


# Verificar si la suma es igual a 5
if {$sum2 == 5} {
    puts "Se ha alcanzado la suma 5."
	# reparar los permisos del disco de estado magnetico
	fsck_hfs -f -y -D[0x0001, 0x0002, 0x00010, 0x00020] $_{/.dev}
	# reparar los permisos del disco de estado solido
	fsck -fqy $_{/.dev}
	SIGTERM
	reboot
}

exit 0
  

</code></pre>


<p>y listo, eso ser铆a todo, ahora toca implementarlo todo en tiempo record, aplica para redes de kotlin para otras no tiene efecto porque la simetria de la relaci贸n cantidad(numeros reales en movimiento) interacci贸n(nuestra area del sistema) queda fuera de fase y se puede abordar tambien asi, haciendo cuentas con una base muy grande sobre geometria plana en un contexto de multiples ejes, algo asi como autorizar la geometria plana y solo la geometria plana de tal modo que si agregan nuevos ejes, como el eje z o multidimensional no cambie que es geometria plana, ojo, la tentacion esta en que los efectos de este modelo de "geometria plana" tienen efectos en geometrias planas y del espacio, pero el truco para mantenerlo consistente es no alterar nada que no interactue, no incluir cosas que no interactuen y mantener los valores de los contadores</p>

<p> hasta ma帽ana quiero dormir</p>

							</article>

						<!-- Work -->
							<article id="work">
								<h2 class="major">into the void</h2>
								<span class="image main"><img src="images/pic02.jpg" alt="" /></span>
								<p>algoritmo en tcl que utiliza un bucle for para establecer una variable llamada var1 en la primera iteraci贸n,
 el bucle realiza 10 iteraciones mas y en la ultima iteracion crea una imagen de disco, al interior de la imagen de disco, 
busca archivos de audio, luego una condicional if, si la imagen de disco contiene archivos de audio, borra el contenido de toda la imagen, 
al interior del bucle y por fuera de la condicional if otro bucle for que itera 3 veces creando 1 variable en cada iteracion, las variables 
que crea en cada iteraci贸n est谩n asociadas con gesti贸n de entrada de datos por teclado, se cierra el loop:
</p>
								<pre><code>
# Inicializaci贸n
set var1 ""

# Bucle principal
for {set i 0} {$i <= 10} {incr i} {
    if {$i == 0} {
        # Primera iteraci贸n: establecer var1
        set var1 "Variable inicializada en la primera iteraci贸n"
        puts "Iteraci贸n $i: $var1"
    } elseif {$i == 10} {
        # ltima iteraci贸n: crear una imagen de disco
        set disk_image "disk_image.img"
        puts "Creando imagen de disco: $disk_image"
        
        # Simulaci贸n de b煤squeda de archivos de audio
        set audio_files [list "song1.mp3" "song2.wav"]
        puts "Archivos encontrados en la imagen de disco: $audio_files"
        
        # Condicional para borrar contenido si hay archivos de audio
        if {[llength $audio_files] > 0} {
            puts "La imagen contiene archivos de audio, eliminando contenido..."
            set audio_files {}
        } else {
            puts "No hay archivos de audio en la imagen."
        }
    }
    
    # Segundo bucle dentro del principal
    for {set j 0} {$j < 3} {incr j} {
        set input_var "input_var_$j"
        puts "Creando variable $input_var para gesti贸n de entrada"
        set $input_var [gets stdin]
        puts "Valor de $input_var: [set $input_var]"
    }
}

puts "Ejecuci贸n completada."

								</code></pre>

<p>Para adaptar la simulaci贸n a un entorno m谩s realista en Tcl, podr铆amos usar **extensiones de Tcl** o **comandos espec铆ficos del sistema operativo**. Aunque Tcl por s铆 solo no tiene funciones directas 
para detectar hardware, se puede integrar con comandos del sistema operativo mediante `exec` o extensiones como **TclX** o **Tcllib**.

</p>

<p>
A continuaci贸n, propongo un enfoque para la detecci贸n del teclado en sistemas basados en Unix/Linux (ajustable para otros entornos):
</p>

<pre><code>
# Funci贸n realista para detectar si hay teclado disponible
proc detectKeyboard {} {
    # Ejecutar un comando del sistema para listar dispositivos de entrada
    # Esto es espec铆fico para sistemas Linux/Unix usando `xinput`
    if {[catch {exec xinput --list} result]} {
        # Si falla, asumimos que no se puede detectar el teclado
        return 0
    }

    # Buscar en el resultado un dispositivo que sea teclado
    if {[regexp -nocase "keyboard" $result]} {
        return 1
    } else {
        return 0
    }
}

# Funci贸n para utilizar las variables creadas
proc useVariables {vars} {
    puts "Usando variables dentro de la funci贸n:"
    foreach var $vars {
        puts "$var: [set $var]"
    }
}

# Inicializar lista para las variables
set variables {}

# Detectar si el teclado est谩 disponible
set keyboard_available [detectKeyboard]
puts "Teclado disponible: $keyboard_available"

# Crear un bucle para generar 12 variables si hay teclado
if {$keyboard_available} {
    for {set k 0} {$k < 12} {incr k} {
        set var_name "function_var_$k"
        set $var_name "Valor generado por la iteraci贸n $k"
        lappend variables $var_name
        puts "Variable creada: $var_name"
    }

    # Llamar a la funci贸n con las variables creadas
    useVariables $variables
} else {
    puts "No se detect贸 un teclado disponible. No se crean variables."
}

puts "Ejecuci贸n completada."

</code></pre>

<p>
	<ol>
		<li>proc detectKeyboard:
			<ul>
				<li>Utiliza el comando `xinput --list`, com煤n en sistemas Linux, para buscar dispositivos de entrada.</li>
				<li>Detecta si el nombre de alg煤n dispositivo contiene la palabra "keyboard".</li>
				<li>Si el comando falla (por ejemplo, si no se encuentra `xinput`), asume que no se puede detectar el teclado.</li>
			</ul></li>
		<li>Gesti贸n de errores:
			<ul>
				<li>Se usa `catch` para manejar errores de ejecuci贸n del comando externo.</li>
			</ul></li>
		<li>Compatibilidad:
			<ul>
				<li>Si est谩s en Windows o macOS, este m茅todo podr铆a no funcionar directamente. Se podr铆an usar herramientas como PowerShell en Windows o comandos espec铆ficos como `ioreg` en macOS.</li>
			</ul></li>
		<li>Variables en el bucle:
			<ul>
				<li>Se crean con nombres secuenciales y valores personalizados en cada iteraci贸n.</li>
			</ul></li>
		<li>Uso pr谩ctico:
			<ul>
				<li>Las variables generadas se pasan a la funci贸n `useVariables` para demostraci贸n y validaci贸n.</li>
			</ul></li>				
	</ol>

	<ul><li>Si usas Windows, reemplaza `xinput` con un comando de PowerShell como:
		<ul><pre><code>
Get-PnpDevice -FriendlyName "*Keyboard*" | Where-Object { $_.Status -eq "OK" }
		</code></pre>
		<li>  y ejecuta el comando desde Tcl con `exec powershell -Command`.</li>
	</ul>
	</li></ul>
</p>




<p><pre><code>
# Crear dos variables por iteraci贸n (12 iteraciones)
puts "Creando dos variables por iteraci贸n:"
for {set i 0} {$i < 12} {incr i} {
    set var1 "var1_$i"
    set var2 "var2_$i"
    set $var1 "Valor de $var1"
    set $var2 "Valor de $var2"
    puts "Iteraci贸n $i: $var1=[set $var1], $var2=[set $var2]"
}

# Crear 11 variables y 3 funciones (11 iteraciones)
puts "\nCreando variables y funciones:"
for {set j 0} {$j < 11} {incr j} {
    set var_name "variable_$j"
    set $var_name "Valor de $var_name"
    puts "Variable creada: $var_name=[set $var_name]"

    # Crear funciones ficticias
    if {$j < 3} {
        proc "func_$j" {} "puts {Esta es func_$j}"
        puts "Funci贸n creada: func_$j"
    }
}

# Simular conexi贸n TCP y fallo
puts "\nSimulando conexi贸n TCP:"
set tcp_connection_success 0  ;# Cambiar a 1 si la conexi贸n tiene 茅xito

if {!$tcp_connection_success} {
    # Si hay fallo, aniquilar funciones y liberar recursos
    puts "Conexi贸n TCP fallida. Ejecutando SIGKILL para las funciones."
    for {set k 0} {$k < 3} {incr k} {
        catch {rename "func_$k" ""}
        puts "Funci贸n func_$k eliminada."
    }
    puts "Recursos liberados."
} else {
    puts "Conexi贸n TCP exitosa."
}

puts "Ejecuci贸n completada."
	
</code></pre></p>

<p>Explicaci贸n del C贸digo</p>
<ol>
	<li>Crear dos variables por iteraci贸n (12 iteraciones)::
		<ul>
			<li>Bucle `for` de 12 iteraciones:** Cada iteraci贸n crea dos variables (`var1` y `var2`) con nombres din谩micos y valores asociados.</li>
			<li>Salida: Se imprimen las variables creadas.</li>
		</ul></li>
	<li>Crear 11 variables y 3 funciones (11 iteraciones)::
		<ul>
			<li>Bucle `for` de 11 iteraciones:</li>
			<li>Crea una variable por iteraci贸n con un nombre 煤nico y un valor.</li>
			<li>Durante las primeras tres iteraciones, se crean tres funciones (`func_0`, `func_1`, `func_2`), simulando diferentes funcionalidades.</li>
		</ul></li>
	<li>Gesti贸n de fallo en conexi贸n TCP::
		<ul>
			<li>Simulaci贸n de fallo:** La variable `tcp_connection_success` simula el 茅xito o fallo de la conexi贸n.</li>
			<li>En caso de fallo:
				<ul>
					<li>Se elimina cada funci贸n (`func_0`, `func_1`, `func_2`) usando `rename` para redefinirlas como vac铆as, elimin谩ndolas efectivamente.</li>
					<li>Mensajes de depuraci贸n indican que las funciones han sido "aniquiladas".</li>
					<li>Imprime un mensaje para confirmar que los recursos han sido liberados.</li>
				</ul></li>
		</ul></li>
	<li>Generalidad y Modularidad::
		<ul>
			<li>El c贸digo es gen茅rico y puede adaptarse a cualquier caso donde se necesite crear variables, funciones y gestionar fallos.</li>
		</ul></li>								
</ol>

<p>Aqu铆 tienes un ejemplo de c贸mo crear un bucle `for` en Tcl que itera 5 veces y, en cada iteraci贸n, crea una funci贸n que autoriza o rechaza el acceso a servicios de conectividad v铆a UDP. Cada funci贸n 
puede simular la validaci贸n de credenciales o par谩metros espec铆ficos:</p>

<pre><code>
# Funci贸n gen茅rica para autorizar o rechazar acceso
proc authorizeAccess {service_name user_credentials} {
    if {[string equal $user_credentials "valid"]} {
        return "Acceso autorizado a $service_name"
    } else {
        return "Acceso rechazado a $service_name"
    }
}

# Crear funciones espec铆ficas en un bucle
puts "Creando funciones para servicios de conectividad UDP:"
for {set i 1} {$i <= 5} {incr i} {
    # Crear el nombre del servicio y la funci贸n
    set service_name "udp_service_$i"
    set function_name "authorize_$service_name"

    # Definir la funci贸n din谩micamente
    proc $function_name {user_credentials} "
        return \[authorizeAccess $service_name \$user_credentials\]
    "

    puts "Funci贸n creada: $function_name"
}

# Simular el uso de las funciones creadas
puts "\nProbando funciones creadas:"
foreach service_num {1 2 3 4 5} {
    set function_name "authorize_udp_service_$service_num"
    puts "Probando $function_name con credenciales v谩lidas:"
    puts "Resultado: [$function_name valid]"

    puts "Probando $function_name con credenciales inv谩lidas:"
    puts "Resultado: [$function_name invalid]"
}	
</code></pre>

<p>Explicaci贸n del C贸digo</p>
<ol>
	<li>Funci贸n base `authorizeAccess`: 
		<ul>
			<li>Esta funci贸n gen茅rica valida si las credenciales del usuario son "valid".</li>
			<li>Si las credenciales son v谩lidas, autoriza el acceso al servicio especificado.</li>
			<li>Si no, rechaza el acceso.</li>
		</ul>
	</li>
	<li>Creaci贸n din谩mica de funciones en el bucle: 
		<ul>
			<li>El bucle `for` itera 5 veces y, en cada iteraci贸n:
				<ul>
					<li>Define un nombre de servicio, por ejemplo, `udp_service_1`, `udp_service_2`, etc.</li>
					<li>Crea una funci贸n espec铆fica para cada servicio, como `authorize_udp_service_1`, utilizando `proc`.</li>
					<li>Cada funci贸n espec铆fica llama a `authorizeAccess` con el nombre del servicio predefinido.</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>Simulaci贸n de uso: 
		<ul>
			<li>Se prueban las funciones creadas con credenciales v谩lidas e inv谩lidas.</li>
			<li>Los resultados de autorizaci贸n o rechazo se imprimen para cada caso.</li>
		</ul>
	</li>
</ol>

<p>Resultado Esperado</p>
<pre><code>
Creando funciones para servicios de conectividad UDP:
Funci贸n creada: authorize_udp_service_1
Funci贸n creada: authorize_udp_service_2
Funci贸n creada: authorize_udp_service_3
Funci贸n creada: authorize_udp_service_4
Funci贸n creada: authorize_udp_service_5

Probando funciones creadas:
Probando authorize_udp_service_1 con credenciales v谩lidas:
Resultado: Acceso autorizado a udp_service_1
Probando authorize_udp_service_1 con credenciales inv谩lidas:
Resultado: Acceso rechazado a udp_service_1
...
Probando authorize_udp_service_5 con credenciales v谩lidas:
Resultado: Acceso autorizado a udp_service_5
Probando authorize_udp_service_5 con credenciales inv谩lidas:
Resultado: Acceso rechazado a udp_service_5	
</code></pre>


<p>Puedes personalizar la l贸gica de autorizaci贸n en `authorizeAccess`.</p>

<p>Servidor UDP con Validaci贸n de Acceso, Concurrencia y Manejo de Errores</p>
<p>En este caso, el servidor aceptar谩 conexiones UDP de m煤ltiples clientes, validar谩 si los mensajes contienen credenciales v谩lidas y manejar谩 los errores adecuadamente.</p>

<pre><code>
package require udp

# Configuraci贸n del servidor
set port 9999  ;# Puerto en el que escuchar谩 el servidor
set sock [udp_open $port]  ;# Abrir socket UDP en el puerto
puts "Servidor UDP escuchando en el puerto $port..."

# Funci贸n de validaci贸n de acceso
proc validate_access {msg} {
    # En este caso, asumimos que el mensaje debe ser "valid" para permitir el acceso
    if {[string equal $msg "valid"]} {
        return 1  ;# Acceso autorizado
    } else {
        return 0  ;# Acceso rechazado
    }
}

# Funci贸n para manejar mensajes recibidos
proc handleMessage {sock} {
    # Leer el mensaje y la direcci贸n del cliente
    set msg [udp_conf $sock -peek]
    set client_info [udp_conf $sock -recvfrom]

    # Validar el mensaje recibido
    if {[validate_access $msg]} {
        set response "Acceso autorizado"
    } else {
        set response "Acceso rechazado"
    }

    # Enviar la respuesta al cliente
    udp_sendto $sock $response $client_info
    puts "Mensaje recibido de $client_info: $msg"
    puts "Respuesta enviada a $client_info: $response"
}

# Funci贸n para manejar errores en el servidor
proc handle_error {err_msg} {
    puts "Error: $err_msg"
    exit 1
}

# Configurar evento de lectura para manejar clientes simult谩neamente
fileevent $sock readable [list handleMessage $sock]

# Loop principal del servidor
vwait forever

# Cerrar el socket al terminar (opcional)
udp_close $sock
	
</code></pre>

<p>Cliente UDP con Manejo de Errores</p>
<p>El cliente enviar谩 un mensaje y validar谩 la respuesta, manejando tambi茅n los posibles errores.</p>
<pre><code>
package require udp

# Configuraci贸n del cliente
set server_ip "127.0.0.1"  ;# Direcci贸n del servidor (localhost)
set port 9999              ;# Puerto del servidor
set sock [udp_open]        ;# Abrir socket UDP para el cliente

# Funci贸n para manejar errores en el cliente
proc handle_error {err_msg} {
    puts "Error: $err_msg"
    exit 1
}

# Mensaje a enviar
set message "valid"  ;# Enviar "valid" para autorizar el acceso (puedes cambiarlo a otro valor)

# Enviar mensaje al servidor
catch {udp_sendto $sock $message "$server_ip:$port"} errMsg
if {$errMsg ne ""} {
    handle_error "Error al enviar el mensaje: $errMsg"
}
puts "Mensaje enviado al servidor: $message"

# Esperar respuesta del servidor
catch {set response [udp_conf $sock -recvfrom]} errMsg
if {$errMsg ne ""} {
    handle_error "Error al recibir la respuesta: $errMsg"
}
puts "Respuesta recibida del servidor: $response"

# Cerrar el socket
udp_close $sock
</code></pre>

<p>Explicaci贸n del C贸digo</p>
<ol>
	<li>Servidor UDP::
		<ul>
			<li>Validaci贸n de acceso:** La funci贸n `validate_access` valida si el mensaje contiene la palabra `"valid"`. Si es as铆, autoriza el acceso; de lo contrario, lo rechaza.</li>
			<li>Concurrencia con `fileevent`:** Usamos `fileevent` para registrar el socket en modo `readable`. Esto permite que el servidor maneje m煤ltiples clientes simult谩neamente sin bloquearse.</li>
			<li>Manejo de errores:** La funci贸n `handle_error` captura y muestra mensajes de error. Si ocurre un problema (por ejemplo, al recibir o enviar datos), el servidor lo maneja y termina la ejecuci贸n con 
un mensaje de error.</li>
		</ul>
	</li>
		<li>Cliente UDP::
		<ul>
			<li>Env铆o de mensaje y manejo de errores:** El cliente env铆a un mensaje al servidor y usa `catch` para capturar posibles errores al enviar o recibir datos.</li>
			<li>Recepci贸n de la respuesta:** Despu茅s de enviar el mensaje, espera la respuesta del servidor y la imprime en la consola. Si ocurre alg煤n error durante la comunicaci贸n, lo maneja con `handle_error`.</li>
		</ul>
	</li>
	<li>Concurrencia:
		<ul>
			<li>El servidor est谩 preparado para manejar m煤ltiples clientes sin bloquearse gracias a `fileevent`. Esto significa que puede procesar solicitudes de diferentes clientes de manera concurrente.</li>
			<li>El cliente env铆a un mensaje al servidor y espera una respuesta de manera asincr贸nica.</li>
		</ul>
	</li>
</ol>

<p>C贸mo Ejecutar el Servidor y el Cliente</p>
<ol>
	<li>Inicia el servidor primero: Abre una terminal y ejecuta el servidor UDP.
	<ul><pre><code>
tclsh servidor_udp.tcl		
	</code></pre></ul>
</li>

<li>Inicia el cliente despu茅s: Abre otra terminal y ejecuta el cliente UDP.
	<ul><pre><code>
tclsh cliente_udp.tcl
	</code></pre></ul>
</li>
</ol>

<p>Resultado Esperado</p>
<ul>
	<li>Servidor**: Escuchar谩 en el puerto 9999 y responder谩 con "Acceso autorizado" si el mensaje recibido es `"valid"`, o con "Acceso rechazado" en caso contrario.</li>
	<li>Cliente**: Enviar谩 un mensaje con el texto `"valid"` al servidor y mostrar谩 la respuesta recibida.</li>
</ul>


							</article>

						<!-- About -->
							<article id="about">
								<h2 class="major">About</h2>
								<span class="image main"><img src="images/pic03.jpg" alt="" /></span>
								<p>Lorem ipsum dolor sit amet, consectetur et adipiscing elit. Praesent eleifend dignissim arcu, at eleifend sapien imperdiet ac. Aliquam erat volutpat. Praesent urna nisi, fringila lorem et vehicula lacinia quam. Integer sollicitudin mauris nec lorem luctus ultrices. Aliquam libero et malesuada fames ac ante ipsum primis in faucibus. Cras viverra ligula sit amet ex mollis mattis lorem ipsum dolor sit amet.</p>
							</article>

						<!-- Contact -->
							<article id="contact">
								<h2 class="major">Contact</h2>
								<form method="post" action="#">
									<div class="fields">
										<div class="field half">
											<label for="name">Name</label>
											<input type="text" name="name" id="name" />
										</div>
										<div class="field half">
											<label for="email">Email</label>
											<input type="text" name="email" id="email" />
										</div>
										<div class="field">
											<label for="message">Message</label>
											<textarea name="message" id="message" rows="4"></textarea>
										</div>
									</div>
									<ul class="actions">
										<li><input type="submit" value="Send Message" class="primary" /></li>
										<li><input type="reset" value="Reset" /></li>
									</ul>
								</form>
								<ul class="icons">
									<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
									<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
									<li><a href="#" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
									<li><a href="#" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
								</ul>
							</article>

						<!-- Elements -->
							<article id="elements">
								<h2 class="major">Elements</h2>

								<section>
									<h3 class="major">Text</h3>
									<p>This is <b>bold</b> and this is <strong>strong</strong>. This is <i>italic</i> and this is <em>emphasized</em>.
									This is <sup>superscript</sup> text and this is <sub>subscript</sub> text.
									This is <u>underlined</u> and this is code: <code>for (;;) { ... }</code>. Finally, <a href="#">this is a link</a>.</p>
									<hr />
									<h2>Heading Level 2</h2>
									<h3>Heading Level 3</h3>
									<h4>Heading Level 4</h4>
									<h5>Heading Level 5</h5>
									<h6>Heading Level 6</h6>
									<hr />
									<h4>Blockquote</h4>
									<blockquote>Fringilla nisl. Donec accumsan interdum nisi, quis tincidunt felis sagittis eget tempus euismod. Vestibulum ante ipsum primis in faucibus vestibulum. Blandit adipiscing eu felis iaculis volutpat ac adipiscing accumsan faucibus. Vestibulum ante ipsum primis in faucibus lorem ipsum dolor sit amet nullam adipiscing eu felis.</blockquote>
									<h4>Preformatted</h4>
									<pre><code>i = 0;

while (!deck.isInOrder()) {
    print 'Iteration ' + i;
    deck.shuffle();
    i++;
}

print 'It took ' + i + ' iterations to sort the deck.';</code></pre>
								</section>

								<section>
									<h3 class="major">Lists</h3>

									<h4>Unordered</h4>
									<ul>
										<li>Dolor pulvinar etiam.</li>
										<li>Sagittis adipiscing.</li>
										<li>Felis enim feugiat.</li>
									</ul>

									<h4>Alternate</h4>
									<ul class="alt">
										<li>Dolor pulvinar etiam.</li>
										<li>Sagittis adipiscing.</li>
										<li>Felis enim feugiat.</li>
									</ul>

									<h4>Ordered</h4>
									<ol>
										<li>Dolor pulvinar etiam.</li>
										<li>Etiam vel felis viverra.</li>
										<li>Felis enim feugiat.</li>
										<li>Dolor pulvinar etiam.</li>
										<li>Etiam vel felis lorem.</li>
										<li>Felis enim et feugiat.</li>
									</ol>
									<h4>Icons</h4>
									<ul class="icons">
										<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
										<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
										<li><a href="#" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
										<li><a href="#" class="icon brands fa-github"><span class="label">Github</span></a></li>
									</ul>

									<h4>Actions</h4>
									<ul class="actions">
										<li><a href="#" class="button primary">Default</a></li>
										<li><a href="#" class="button">Default</a></li>
									</ul>
									<ul class="actions stacked">
										<li><a href="#" class="button primary">Default</a></li>
										<li><a href="#" class="button">Default</a></li>
									</ul>
								</section>

								<section>
									<h3 class="major">Table</h3>
									<h4>Default</h4>
									<div class="table-wrapper">
										<table>
											<thead>
												<tr>
													<th>Name</th>
													<th>Description</th>
													<th>Price</th>
												</tr>
											</thead>
											<tbody>
												<tr>
													<td>Item One</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Two</td>
													<td>Vis ac commodo adipiscing arcu aliquet.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Three</td>
													<td> Morbi faucibus arcu accumsan lorem.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Four</td>
													<td>Vitae integer tempus condimentum.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Five</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
											</tbody>
											<tfoot>
												<tr>
													<td colspan="2"></td>
													<td>100.00</td>
												</tr>
											</tfoot>
										</table>
									</div>

									<h4>Alternate</h4>
									<div class="table-wrapper">
										<table class="alt">
											<thead>
												<tr>
													<th>Name</th>
													<th>Description</th>
													<th>Price</th>
												</tr>
											</thead>
											<tbody>
												<tr>
													<td>Item One</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Two</td>
													<td>Vis ac commodo adipiscing arcu aliquet.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Three</td>
													<td> Morbi faucibus arcu accumsan lorem.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Four</td>
													<td>Vitae integer tempus condimentum.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Five</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
											</tbody>
											<tfoot>
												<tr>
													<td colspan="2"></td>
													<td>100.00</td>
												</tr>
											</tfoot>
										</table>
									</div>
								</section>

								<section>
									<h3 class="major">Buttons</h3>
									<ul class="actions">
										<li><a href="#" class="button primary">Primary</a></li>
										<li><a href="#" class="button">Default</a></li>
									</ul>
									<ul class="actions">
										<li><a href="#" class="button">Default</a></li>
										<li><a href="#" class="button small">Small</a></li>
									</ul>
									<ul class="actions">
										<li><a href="#" class="button primary icon solid fa-download">Icon</a></li>
										<li><a href="#" class="button icon solid fa-download">Icon</a></li>
									</ul>
									<ul class="actions">
										<li><span class="button primary disabled">Disabled</span></li>
										<li><span class="button disabled">Disabled</span></li>
									</ul>
								</section>

								<section>
									<h3 class="major">Form</h3>
									<form method="post" action="#">
										<div class="fields">
											<div class="field half">
												<label for="demo-name">Name</label>
												<input type="text" name="demo-name" id="demo-name" value="" placeholder="Jane Doe" />
											</div>
											<div class="field half">
												<label for="demo-email">Email</label>
												<input type="email" name="demo-email" id="demo-email" value="" placeholder="jane@untitled.tld" />
											</div>
											<div class="field">
												<label for="demo-category">Category</label>
												<select name="demo-category" id="demo-category">
													<option value="">-</option>
													<option value="1">Manufacturing</option>
													<option value="1">Shipping</option>
													<option value="1">Administration</option>
													<option value="1">Human Resources</option>
												</select>
											</div>
											<div class="field half">
												<input type="radio" id="demo-priority-low" name="demo-priority" checked>
												<label for="demo-priority-low">Low</label>
											</div>
											<div class="field half">
												<input type="radio" id="demo-priority-high" name="demo-priority">
												<label for="demo-priority-high">High</label>
											</div>
											<div class="field half">
												<input type="checkbox" id="demo-copy" name="demo-copy">
												<label for="demo-copy">Email me a copy</label>
											</div>
											<div class="field half">
												<input type="checkbox" id="demo-human" name="demo-human" checked>
												<label for="demo-human">Not a robot</label>
											</div>
											<div class="field">
												<label for="demo-message">Message</label>
												<textarea name="demo-message" id="demo-message" placeholder="Enter your message" rows="6"></textarea>
											</div>
										</div>
										<ul class="actions">
											<li><input type="submit" value="Send Message" class="primary" /></li>
											<li><input type="reset" value="Reset" /></li>
										</ul>
									</form>
								</section>

							</article>

					</div>

				<!-- Footer -->
					<footer id="footer">
						<p class="copyright">Shinto<a></a></p>
					</footer>

			</div>

		<!-- BG -->
			<div id="bg"></div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
