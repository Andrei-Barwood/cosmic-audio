<!DOCTYPE HTML>
<!--
	Dimension by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>St. Petersburg Stakeout</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<div class="logo">
							<span class="icon fa-gem"></span>
						</div>
						<div class="content">
							<div class="inner">
								<h1>no te aproveches</h1>
								<p>de vez en cuando el enemigo te da ventaja en la carrera porque quiere jugar a la liebre y la tortuga, no te aproveches, usualmente es una trampa, esperalo a su proximo turno, no te saltes turnos, va a pica pala</p>
							</div>
						</div>
						<nav>
							<ul>
								<li><a href="#intro">St. Petersburg Stakeout</a></li>
<!--								<li><a href="#work">Work</a></li>
								<li><a href="#about">About</a></li>
								<li><a href="#contact">Contact</a></li>
								<li><a href="#intro">Intro</a></li>
								<li><a href="#work">Work</a></li>
								<li><a href="#about">About</a></li>
								<li><a href="#contact">Contact</a></li> -->
								<!--<li><a href="#elements">Elements</a></li>-->
							</ul>
							<!-- <ul><li><a href="#work">into the void</a></li></ul> -->
						</nav>
					</header>

				<!-- Main -->
					<div id="main">

						<!-- Intro -->
							<article id="intro">
								<h2 class="major">St. Petersburg Stakeout</h2>
								<span class="image main"><img src="images/pic01.jpg" alt="" /></span>
								<p>captura la bandera, re-fácil, bien podría hacerlo yo mismo y publicarte los resultados pero eso, si, que seria un error, porque no puedo ignorarte asi nomás, ¿porque? fácil, porque hay cosas que tu desde donde estas ubicada estás observando y yo no, porque estoy en otra ubicación, asi pues lo que comparto aquí son los algoritmos, un poco como los planos pero tu decides DONDE construirlos, para efectos de un ejemplo conciso, remplaza los titulos genericos con nombres espcificos en ocasiones pueden ser urls que siempre se deben expresar de la siguiente manera <pre><code>"/.urls/soyelfrailecarlitos.com"</code></pre>
								para el caso de que el sitio web del fraile carlitos represente una contravención agravada y escueta, por razones muy obvias tengo que explicarte que esto no tiene nada que ver con snocomm directamente, es mas bien como parte de DED en CONCORD. ¿que es CONCORD?
							</p>

							<h3>¿que es que?</h3>
							<p>CONCORD: es una organización independiente fundada aproximadamente hace un siglo, se creó para facilitar negociaciones entre diferentes razas para mejorar relaciones burocraticas, y motivar asi comercio y relaciones exteriores a traves del cobro de impuestos y disposición policial interplanetaria (con ciertas excepciones porque CONCORD no protege ratas ni asesinos pero si, tiene presencia policial)</p>

							<p>Consolidated Cooperation and Relations Command (CONCORD)</p>
							<p>comenzó como un terreno neutral de reuniones y conferencias para diplomáticos y oficiales de diferentes procedencias, diferentes facciones, influyentes y de proporciones gigantescas confían en CONCORD y poco a poco su influencia a aumentado y su poder también. Se financia mediante proyectos personalizados, confiscar contrabando y trafico de especies exóticas, y otras obligaciones.</p>

							<p>CONCORD cumple un rol neutral y por tanto todos los participantes de todas las grandes facciones discuten, debaten, denuncian y solucionan las circunstancias tan frágiles en las que se encuentra el tema interestelar. Las soluciones se obtienen a traves de documentación y compromisos so pena de multas por incumplimientos y otras clausulas. Se ha convertido en una institución independiente, y no ejerce bajo la influencia de ninguna facción, influencia y confianza son dos cosas diferentes, ellos tienen permitido confiar pero no tienen permitido influir. Es bueno mantener las diferencias y que CONCORD sea independiente es una garantía de su neutralidad</p>

							<p>DED (directive Enforcement Department)</p>
							<p>DED es el "brazo policial fuertemente armado" de CONCORD, tiene como responsabilidad ubicar criminales y destruir instalaciones, recintos y edificaciones criminales que se encuentren porfuera de las fronteras de los espacios de alta seguridad, es la división que se encarga de perseguir indefinidamente a través del espacio hasta destruir sus objetivos, es la división a la cual se acude cuando ocurren actos de violencia o crimenes a manos de convoys, mas de 10 o 20 unidades enemigas o casos parecidos se reportan en DED para su destrucción, no gestionan arrestos ni testigos o recolección de evidencias o negociaciones, es una división puramente policial</p>

							<p>lo que hoy vamos a abordar es una denuncia que se realizó a DED y que la división CDIA (CONCORD Directive Intelligence Agency) se ofreció a solucionar. como su nombre lo indicá CDIA ofrece y obtiene intel de situaciones, lugares, actitudes, facciones ilegales, anomalías y demás. CDIA tiene personas que pueden interpretar, lo que hoy vamos a formular como posible respuesta a dicha denuncia, pueden interpretarlo de manera realista. es un ejercicio muy sencillo y puede probar ser útil apesar de tener un método genérico, pues, lo genérico se convierte en interesante a través de CDIA. si usted está interesado en el stakeout y puede contribuir a continuación se delinean una referencia y posibles implementaciones sobre la primera de 15 denuncias presentadas en contra del 'demandado' cuyo nombre permanece secreto, porque la justicia a pesar de ser justa debe ser ciega.</p>

							<p>¿Que es una contravención?</p>
							<p>tiene una respuesta mucho mas elaborada en terminos de documentacion legal pero resumiendo un poco una contravención es toda actitud o obstrucción que genere distorsión al interior de un contexto cuyo origen no sea documentado como crimen. distorsionar las leyes con analogías, o reglamentaciones vagas que justifican cualquier atentado en contra del marco social democratico tiene, en varios casos prisión por acto criminal. Si, algunas contravenciones pueden ser procesadas, no todas, pero si varias, la carta civil conocida como constitucion politica de la nacion es un documento escueto que parece mas una carta de iglesia. El caso del documento que define la ley penal militar y su forma de solucionar crimenes y sentencias están, en contraste con la carta civil, basado en el derecho a la dignidad humana entre otras virtudes humanas desarrolladas mediante la discplina, el mutuo respeto, la mutua autoregulacion en casos de contrato o compromisos legales documentados que no vale la pena incluir en una carta de iglesia porque automaticamente todos se delcararían pecadores y que son pecadores y punto, 👉. Shimura los describiria diciendo "Cobardes que no tienen respeto por la palabra dada no merecen misericordia", para mi no merecen nada, ni trabajo, ni oportunidades porque las van a desaprovechar y desperdiciar tratando de ser pecadores. Decir mentiras en la corte es una contravención por afirmaciones falsas porque se tipifica que la calumnia tiene intencion delictiva. Para DED todas las denuncias que presenten antecedentes contravencionales tienen procedencia de orden legal en sentencias judiciales definitivas, la diferencia con otras instituciones policiales (la contravencion es un instrumento legal pero de uso policial), es que DED obtiene dicho intel en función de la destrucción del objetivo, en función de motivar el desarrollo tecnológico los extractores "octopus 8" de calibre 360, "kingzer", "Dia", "Luna" y similares están permitidos en su uso durante operativos policiales, lo que ocurra con el lote de accesorios, items y demás objetos que sobrevivan a las explosiones durante la destrucción de la nave objetivo pierden propiedad y se consideran propiedad de quien las encuentre, se pueden vender y comerciar por creditos financieros de la divisa local en el territorio en el que se encuentre y no hay multa o sanción. Pueden desaparecer debido a las explosiones o quedar incompletos por el enfrentamiento, por lo tanto si el enemigo las utiliza como evidencia, el argumento legal, es que una evidencia de inocencia no debe representar ante ninguna instancia de la justicia una norma penal vaga, a propósito de evidencias malformadas o destruidas o deterioradas, porque incluyen elementos ambiguos, inciertos, o equívocos sobre la inocencia de un presunto criminal denunciado ante DED. El hecho preterintencional no es redundante y puede ser condenado como preterintencional aun y cuando la evidencia sea escueta o vaga. En ocasiones se puede opinar sobre DED como una entidad que posee una actitud "arrogante, humillante, despótica, caprichosa, extravagante y desafiante" pero dicha actitud está presente en varios civiles que presentan antecedentes criminales y contravencionales, pero dichas actitudes no tienen carcel. por lo tanto se juzgan al interior de CONCORD como muestras deshonrosas y descargas deshonorables, pues, sea que se analicen las palabras en su sentido literal que justifica actividades criminales y deshonorosas en contra de población inocente considerada objetivos de guerra, o que se examine el contexto en el que se pronunciaron, los matices de vejamen que se encuentren en dicho modelo de comunicación sirven como evidencia de agresión en contra de la honra o persona afectada, que por virtud criminal busca denunciar la sanción policial en la cual las cuatro facciones depositaron su confianza hace un siglo. irrespetuosamente se puede destruir la honra y la salud mental de cualquiera, asi que por eso el tema respeto a la comunicación decente durante el juicio en una corte puede ser objeto de arresto y subsecuente interrupcion del juicio, dando prioridad a otro caso en el cual si se respete la oportunidad de demostrar la inocencia del demandado. La doctrina del hurto o doctrina que justifique actividad criminal se dialogará en un juicio justo, en presencia del fiscal penal militar de garantías de turno, quien evaluará el origen del caso y dentro de un tiempo limitado gestionará los recursos posibles para garantizarle el derecho a un juicio justo, pero ningun oficial de CONCORD tiene la obligacion de divagar con excusas referentes a la carta civil y sus posibles injurias en contra de la tesis de aprehensión ocurrida en circunstancias de delito.</p>

							<p>no es tanto el valor de los algoritmos que vamos a observar sino los recursos que la ley penal militar pone a disposición de un caso cerrado como este, en cuyo caso es importante anotar que la lógica de programación contenida en este software no aplica para todos los contextos de denuncias a DED, pues, se alteraria el contexto y origen de la denuncia subyugando dicho contexto y dicho origen a la inpetitud causada por el abuso de autoridad tan deplorable que sufre el acusado, cuyo nombre permanece secreto por respeto a la justicia</p>

							<p>con secreto me refiero a que los algoritmos no sugieren nombres de variables ni de funciones, la justicia no sabe quienes son los implicados en la denuncia, a la justicia se le informa por medio de instrumentos y mecanismos que evidencian el origen de la denuncia, unos hechos, pero si usted considera que la historia es la misma y que los ineptos son los mismos que abusan de la autoridad que les da el poder que han gestionado, entonces aunque el contexto y origen de la denuncian han sido alterados y se han modificado, la sanción que aplica DED es útil, como advertencia debo informarle que no todos los casos se dejan alterar y modificar para ello habría que revisar denuncias en otros contextos y ver porqué sería una imprudencia modificar o alterar la instancia de contexto y origen</p>

							<h3>Algoritmos en orden de sucesiones:</h3>

							<p>Aquí tienes un esquema de algoritmo en TCL que utiliza dos bucles `for` para funciones diferentes (watchdog con guardian y un francotirador) y dos bucles `for` para funciones idénticas (dos taxis que encubren el acto de corrupción)</p>

							<h4>Descripción del algoritmo</h4>
							<ol>
								<li>Primer `for` (función 1): Calcula una serie de números al cubo. (watchdog and guardian)</li>
								<li>Segundo `for` (función 2): Genera una serie de cadenas concatenadas. (francotirador)</li>
								<li>Tercer `for` (funciones idénticas): Realiza la misma tarea (sumar números) en un rango definido, pero la ejecuta dos veces con bucles separados. (dos taxis)</li>
							</ol>

							<p>recuerda que el código esta en formato genérico, nombres como sum1 uno o sum2 deben ser reemplazados por valores de sistema que se encuentran en tu terminal de la siguiente forma</p>

							<pre><code>
man -k tcp
man -k ssh
							</code></pre>

							<p>etcetera donde el argumento para la opción -k es el servicio que necesitas ubicar: (ssh, tcp, ftp, security, network, storage, error, protocol, son opciones comunes)</p>



<p>1. --- set and match ---
	<pre><code>

# Primer bucle: Calcula los cubos de números del 1 al 5 (watchdog and guardian)
puts "Resultados del primer bucle:"
for {set i 1} {$i <= 33} {incr i} {
    set cube [expr {$i * $i * $i}]
    puts "El cubo de $i es $cube"
}

# Segundo bucle: Genera una lista concatenando cadenas (francotirador)
puts "\nResultados del segundo bucle:"
set concatenated ""
for {set i 1} {$i <= 8} {incr i} {
    append concatenated "Elemento_$i "
}
puts "Cadena concatenada: $concatenated"

# Tercer y cuarto bucle: Suman números del 1 al 5 (función idéntica)
puts "\nResultados de los bucles idénticos:"
set sum1 0
for {set i 1} {$i <= 3} {incr i} {
    set sum1 [expr {$sum1 + $i}]
}
puts "La suma en el tercer bucle es: $sum1"

set sum2 0
for {set i 1} {$i <= 5} {incr i} {
    set sum2 [expr {$sum2 + $i}]
}
puts "La suma en el cuarto bucle es: $sum2"
</code></pre>


en los bucles for no debes alterar los siguientes valores:
<pre><code>
	{$i <= 33}
	{$i <= 8}
	{$i <= 2}
	{$i <= 3}
	{$i <= 5}
</code></pre>
pues dichos valores representan la arquitectura del dispositivo primario, se necesitan de ese tamaño especifico cada uno.
</p>

<p>2. --- get the silver key ---</p>
<p><pre><code>
# Cargar la biblioteca tls
package require tls

# Lista de contraseñas o tokens (CDIA Intel)
set expectedTokens [list "token1" "token2" "token3" "token4" "token5" \
                         "token6" "token7" "token8" "token9" "token10" "token11"]

# Inicializa el estado de autenticación
set authenticated 1  ;# 1 significa autenticado hasta que falle

puts "Iniciando autenticación: Se requieren 11 entradas correctas."

# Bucle de autenticación, mantener {$i < 11} intacto
for {set i 0} {$i < 11} {incr i} {
    # Simula una entrada del usuario (puedes reemplazar por gets stdin para entrada real)
    puts "Ingrese el token para la posición [expr {$i + 1}]:"
    gets stdin userInput ;# "userInput" puede ser remplazada con valores propios

    # Compara la entrada del usuario con el token esperado
    if { $userInput != [lindex $expectedTokens $i] } {
        puts "Autenticación fallida en la posición [expr {$i + 1}]."
        set authenticated 0  ;# establece la autenticación como "no autenticado"
        break
    }
}

# Si la autenticación es exitosa, inicia el servicio TCP/TLS
if {$authenticated} {
    puts "Autenticación exitosa. Iniciando servicio TLS en el puerto 8080..."

    # Configuración de los certificados y claves
    set certFile "server-cert.pem"   ;# Ruta al certificado del servidor (/.urls/etc...)
    set keyFile "server-key.pem"     ;# Ruta a la clave privada del servidor (/.urls/etc...)

    # Función para manejar conexiones TLS
    proc handleTLSConnection {sock addr port} {
        puts "Nueva conexión segura desde $addr:$port"

        # Hacer la conexión TLS segura
        tls::import $sock
        puts $sock "Bienvenido al servicio seguro TLS. Escribe un mensaje:"
        flush $sock

        # Lee datos del cliente y responde
        fileevent $sock readable [list readTLSData $sock]
    }

    # Función para leer datos del cliente en TLS
    proc readTLSData {sock} {
        if {[eof $sock]} {
            close $sock
            puts "Conexión cerrada."
            return
        }
        set data [gets $sock]
        puts "Cliente dice: $data"
        puts $sock "Mensaje recibido de forma segura: $data"
        flush $sock
    }

    # Inicia el servidor seguro TLS
    set server [socket -server handleTLSConnection 8080]
    tls::server configure -certfile $certFile -keyfile $keyFile
    puts "Servicio TLS escuchando en el puerto 8080. Presione Ctrl+C para salir."
    vwait forever  ;# Mantén el servidor ejecutándose
} else {
    puts "Autenticación denegada. Intente de nuevo."
}
</code></pre></p>


<p>Explicación de TLS:</p>
<ol>Certificados y claves:
   <li> Necesitas un archivo de certificado (`server-cert.pem`) y un archivo de clave privada (`server-key.pem`).</li>
   <li> Puedes generar estos archivos utilizando `openssl`. Por ejemplo, al interior de un nuevo documento titulado server-key.sh puedes crearlo:</li>
   <pre><code>
openssl req -x509 -newkey rsa:2048 -keyout server-key.pem -out server-cert.pem -days 365 -nodes
   </code></pre>
   <p>Importación de TLS:</p>
   <li>Cuando un cliente se conecta, el servidor convierte el socket estándar en un socket TLS con `tls::import`.</li>
   <p></p>
   <p>Seguridad:</p>
   <li>Los datos intercambiados entre el cliente y el servidor están encriptados. Esto asegura que la comunicación no pueda ser interceptada fácilmente.</li>

</ol>

<p>Prueba del servidor:</p>
<li>Usa herramientas compatibles con TLS, como `openssl s_client` en un archivo de texto de extensión .zsh:</li>
<pre><code>
openssl s_client -connect localhost:8080	
</code></pre>

<p>Aquí tienes un cliente TCL que se conecta de forma segura al servidor TLS creado anteriormente. Este cliente utiliza el paquete `tls` para realizar la conexión.</p>

<pre><code>
# Cargar la biblioteca tls
package require tls

# Dirección y puerto del servidor
set serverAddress "localhost"  ;# Cambia a la dirección IP o nombre del servidor
set serverPort 8080

# Ruta al archivo de certificado de confianza (si es necesario validar el servidor)
# Puedes usar un certificado auto-firmado o el del servidor
set caFile "server-cert.pem"

# Establecer una conexión segura al servidor TLS
puts "Conectando de forma segura al servidor en $serverAddress:$serverPort..."
set sock [tls::socket $serverAddress $serverPort -cafile $caFile]

# Verificar la conexión
if {[catch {gets $sock welcomeMessage} err]} {
    puts "Error en la conexión: $err"
    exit 1
} else {
    puts "Conexión exitosa: $welcomeMessage"
}

# Interactuar con el servidor (implementación generica, podrias enviar comandos encontrados con man -k al servidor)
# tambien puedes encontrar el gestor de señal a traves del siguiente comando en tu terminal:
# man kill
# debiera listarte las mas comunes: hung up, interrupt, quit, abort, kill, alrm, term


puts "Escriba un mensaje para enviar al servidor (escriba 'exit' para salir):"

while {1} {
    puts -nonewline "Mensaje: "
    flush stdout
    gets stdin userInput

    if {$userInput eq "exit"} {
    	# envia comandos aqui
        puts "Cerrando conexión..."
        close $sock
        exit 0
    }

    # Enviar mensaje al servidor
    # mas comandos aqui
    puts $sock $userInput
    flush $sock

    # Leer respuesta del servidor
    if {[catch {gets $sock serverResponse} err]} {
        puts "Error al recibir respuesta: $err"
        close $sock
        exit 1
    } else {
        puts "Respuesta del servidor: $serverResponse"
    }
}

</code></pre>

<p>Explicación del Cliente:</p>
<ol>

	<li>Conexión TLS:</li>
<ul> 
	<li>Usa `tls::socket` para conectarse al servidor de forma segura.</li>
	<li>`-cafile` permite validar el certificado del servidor. Si el servidor tiene un certificado auto-firmado, usa el mismo archivo que generaste (`server-cert.pem`).</li>
</ul>


	<li>Interacción con el servidor:</li>
<ul> 
	<li>El cliente envía mensajes al servidor y lee las respuestas en un bucle.</li>
	<li>`Escribe "exit" para cerrar la conexión.</li>
</ul>


	<li>Manejo de errores:</li>
<ul> 
	<li>Si hay problemas durante la conexión o la comunicación, el programa mostrará un mensaje y saldrá.</li>
</ul>

<p>recuerda ingresar mensajes en el cliente para interactuar con las respuestas del servidor.</p>


</ol>

<p>3 --- activar el watchdog con guardian ---</p>
<p>Aquí tienes un ejemplo de un algoritmo que utiliza un bucle `for` para iterar 6 veces sobre un diccionario en TCL, ejecutando dos funciones diferentes en cada iteración:</p>



<p>Algoritmo:</p>
<ol>
<li> Define un diccionario con al menos 6 pares clave-valor.</li>
<li>Usa un bucle `for` para iterar exactamente 6 veces.</li>
<li>En cada iteración:<ul>
   <li>Llama a la primera función, que procesa la clave.</li>
   <li>Llama a la segunda función, que procesa el valor.</li>
</ul></li>
<li>Muestra los resultados.</li>
</ol>

<pre><code>
# Definir el diccionario
set myDict {
    "clave1" "valor1"
    "clave2" "valor2"
    "clave3" "valor3"
    "clave4" "valor4"
    "clave5" "valor5"
    "clave6" "valor6"
}

# Definir la primera función: procesa la clave
proc processKey {key} {
    puts "Procesando clave: $key"
    # Agrega lógica personalizada aquí:
    # clausulas if, declaracion de variables o constantes
    # listas, comandos, bucles for etc...

    # una forma interesante de incrustar lenguajes de programación 
    # que no sean tcl dentro de un script tcl
    # es con la siguiente sintáxis:
    	# paréntesis, forward slash, extension del lenguaje de programacion
    	# ejemplo:
    			# nombreDeLaFuncion(/.py) {
 			#   from math import *
 			#	# python code here
 			# }

# la funcion tiene parentesis y corchetes
# como todas las funciones en C, 
# y adentro va el programa que vas a incrustar

    return "Clave procesada: $key"
}

# Definir la segunda función: procesa el valor
proc processValue {value} {
    puts "Procesando valor: $value"
    # Agrega lógica personalizada aquí
    return "Valor procesado: $value"
}

# Iterar sobre el diccionario
puts "Iterando sobre el diccionario..."
set keys [dict keys $myDict]
for {set i 0} {$i < 6} {incr i} {
    set key [lindex $keys $i]
    set value [dict get $myDict $key]

    # Llamar a la primera función con la clave
    set processedKey [processKey $key]

    # Llamar a la segunda función con el valor
    set processedValue [processValue $value]

    # Mostrar resultados
    puts "Resultado clave: $processedKey"
    puts "Resultado valor: $processedValue"
    puts "--------------------------------"
}

</code></pre>

<p>Explicación del Código:</p>
<ol>
	<li>Diccionario: 
		<ul>
			<li>`myDict` contiene 6 pares clave-valor que serán iterados.</li>
		</ul>
	</li>
	<li>Funciones: 
		<ul>
			<li>`processKey` recibe una clave y realiza una acción (en este caso, solo imprime y retorna un mensaje procesado).</li>
			<li>`processValue` hace lo mismo pero con un valor.</li>
		</ul>
	</li>
		<li>Bucle `for: 
		<ul>
			<li>Itera exactamente 6 veces (índices de 0 a 5).</li>
			<li>Usa `dict keys` para obtener todas las claves del diccionario y `dict get` para obtener los valores correspondientes.</li>
		</ul>
	</li>
	<li>Resultados: 
		<ul>
			<li>En cada iteración, se procesan la clave y el valor con sus respectivas funciones.</li>
			<li>Los resultados se imprimen.</li>
		</ul>
	</li>

</ol>

<p>Salida Ejemplo:</p>
<pre><code>
Iterando sobre el diccionario...
Procesando clave: clave1
Procesando valor: valor1
Resultado clave: Clave procesada: clave1
Resultado valor: Valor procesado: valor1
--------------------------------
Procesando clave: clave2
Procesando valor: valor2
Resultado clave: Clave procesada: clave2
Resultado valor: Valor procesado: valor2
--------------------------------

</code></pre>

<p>4. --- acceso a la ubicación del francotirador (SIGKILL source on their side) ---</p>
<p>Algoritmo:</p>
<ol>
	<li>Definir 9 variables booleanas con el valor `true`.</li>
	<li>Usar un bucle `for` para iterar sobre las 9 variables.</li>
	<li>Verificar que todas las variables sean `true` durante cada iteración.</li>
	<li>Si todas las variables son `true` al finalizar el bucle, se autoriza el uso de servicios de red mediante UDP.</li>
</ol>

	<p>CUIDADO! en este algoritmo es imperativo no alterar la cantidad de variables en el paso 1, es imperativo mantener la logica basada en movimiento através de bucles for, verificar y conceder acceso autorizado para evitar que el sistema te rechace o te ignore de imprevisto</p>

<pre><code>
# Definir 9 variables booleanas con valor true
set var1 true
set var2 true
set var3 true
set var4 true
set var5 true
set var6 true
set var7 true
set var8 true
set var9 true

# Lista de variables booleanas
set vars {var1 var2 var3 var4 var5 var6 var7 var8 var9}

# Inicializa el estado de autorización
set authorized 1  ;# 1 significa autorizado, 0 denegado

# Iterar sobre las 9 variables booleanas
for {set i 0} {$i < 9} {incr i} {
    set currentVar [lindex $vars $i]
    
    # Verificar si la variable actual es false
    if {![set $currentVar]} {
        set authorized 0  ;# Denegar autorización si alguna variable es false
        break
    }
}

# Si todas las variables son true, autorizar el uso de UDP
if {$authorized} {
    puts "Todas las variables son TRUE. Autorizando uso de servicios de red con UDP..."
    
    # Configurar el servicio de red UDP
    set udpPort 12345  ;# El puerto para los datagramas UDP
    set serverAddr "localhost"  ;# Dirección del servidor UDP

    # Crear socket UDP
    set sock [socket -type udp $serverAddr $udpPort]
    if {$sock != ""} {
        puts "Socket UDP creado en $serverAddr:$udpPort"
        # Enviar un mensaje a través del socket UDP
        puts $sock "Mensaje de prueba a través de UDP"
        flush $sock
        close $sock
        puts "Mensaje enviado a través de UDP y conexión cerrada."
    } else {
        puts "Error al crear el socket UDP."
    }
} else {
    puts "Autorización fallida. No se puede acceder a los servicios de red."
}
</code></pre>

<p>Salida de ejemplo</p>
<p>Si todas las variables son `true`, la salida será algo como:</p>
<pre><code>
Todas las variables son TRUE. Autorizando uso de servicios de red con UDP...
Socket UDP creado en localhost:12345
Mensaje enviado a través de UDP y conexión cerrada.

</code></pre>

<p>Si alguna variable es `false`, la salida será:</p>
<pre>
	<code>Autorización fallida. No se puede acceder a los servicios de red.</code>
</pre>

<p>ejemplo de ruteo sobre capa 2 del modelo osi sin switch, solo con hub  utilizado en kotlin (kotlin es el lenguaje de programación que utiliza el demandado)</p>
<pre>
	<code>
#[cfg(test)]
mod tests {
	#[test]
	fn it_works() {
		let result = 2 + 2;
		assert_eq!(result, 4);
	}
}
</code>
</pre>



<p>el cual es reemplazado por programación funcional al interior de bucles for para mayor precisión y depuración por fases.
</p>

<p>5. --- interacción con el francotirador ---</p>
<p>Para implementar una sesión remota segura a través de SSH en TCL, puedes usar la biblioteca `ssh` de TCL, que proporciona la funcionalidad necesaria para interactuar con servidores a través de SSH. 
Desafortunadamente, TCL no incluye un paquete de SSH por defecto, pero se puede usar un paquete como `Tcllib` o `ssh2` para establecer una conexión SSH.

A continuación, te proporcionaré un ejemplo de cómo podrías escribir un algoritmo en TCL para iniciar sesión en tu servidor remoto a través de TCP utilizando SSH</p>

<p>Algoritmo:</p>
<ol>
	<li>Establecer la dirección del servidor y el puerto SSH (generalmente el puerto 22).</li>
	<li>Proporcionar las credenciales del usuario (nombre de usuario y contraseña).</li>
	<li>Utilizar la biblioteca SSH para establecer una conexión segura.</li>
	<li>Ejecutar comandos remotos en el servidor.</li>
</ol>

<p>El código en TCL es utilizando `ssh2` (que es un paquete común de SSH en TCL):</p>

<pre>
	<code>
# Cargar la biblioteca de ssh2 (asegúrate de tenerla instalada)
package require ssh2

# Dirección y puerto del servidor SSH
set serverAddress "your.server.com"  ;# Cambia por la dirección del servidor del fraile carlitos
set serverPort 22

# Credenciales del usuario
set username "yourUsername"         ;# Cambia por el nombre de usuario del fraile carlitos
set password "yourPassword"         ;# Cambia por la contraseña del fraile carlitos

# Crear una conexión SSH con autenticación por clave privada
set privateKeyFile "/path/to/private/key"
set sshChannel [ssh2::connect $serverAddress -port $serverPort -username $username -identityfile $privateKeyFile]

# Verificar la conexión
if {![info exists sshChannel]} {
    puts "Error al conectar al servidor SSH."
    exit 1
} else {
    puts "Conexión SSH establecida exitosamente."

# Ejecutar un comando remoto (por ejemplo, 'ls' para listar los archivos)
# o por ejemplo man -k etc...
set command "ls -l"
set result [ssh2::exec $sshChannel $command]

# Mostrar el resultado del comando
puts "Resultado del comando '$command':"
puts $result

# Cerrar la conexión SSH
ssh2::disconnect $sshChannel
puts "Conexión SSH cerrada."

	</code>
</pre>


<p>6. --- asesinar al francotirador y reportar su muerte ---</p>
<p>Este código simula una conexión UDP, maneja errores de conectividad, y genera un log si el proceso termina de manera abrupta (simulando `SIGKILL` usando una terminación controlada o un error). pero tu podrias implementar --kill -s SIGKILL-- en la instancia que corresponda</p>

<pre><code>

package require Tcl 8.6

# Configuración de parámetros de la conexión UDP
set serverAddress "localhost"
set serverPort 12345

# Inicializar log de errores
set logFile "error_log.txt"

# Función para registrar el error
proc log_error {message} {
    global logFile
    set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
    set logMessage "$timestamp - ERROR: $message"
    
    # Escribir en el archivo de log
    set fileId [open $logFile "a"]
    puts $fileId $logMessage
    close $fileId
    puts $logMessage  ;# Mostrar el error en la consola también
}

# Función para manejar el SIGTERM (simulando un error de conectividad que dispara el SIGKILL)
proc handle_SIGTERM {} {
    log_error "El proceso fue terminado inesperadamente debido a un error en la conectividad de UDP."
    exit 1
}

# Manejo de SIGTERM (similar a un error crítico que dispara la terminación del proceso)
trap handle_SIGTERM SIGTERM

# Función para simular la conexión UDP
proc udp_connect {} {
    global serverAddress serverPort

    # Intentar crear el socket UDP
    set sock [socket -type udp $serverAddress $serverPort]
    if {$sock == ""} {
        log_error "Error al crear el socket UDP para $serverAddress:$serverPort."
        exit 1
    }
    puts "Conexión UDP establecida con $serverAddress:$serverPort."

    # Simular un error de conectividad (por ejemplo, el servidor no responde)
    set data "Mensaje de prueba"
    catch {
        puts $sock $data
        flush $sock
    } result

    # Si ocurre un error en el envío, loguearlo y simular un fallo
    if {[string length $result] > 0} {
        log_error "Error en la transmisión UDP: $result"
        close $sock
        exit 1
    }

    # Cerrar la conexión correctamente
    close $sock
    puts "Mensaje enviado exitosamente a través de UDP."
}

# Simular un error de conectividad después de un tiempo
after 5000 {
    udp_connect
}

# Simular un error que puede disparar un SIGKILL (como un fallo en el servidor)
after 10000 {
    # Simulamos que el servidor dejó de responder o alguna otra razón que cause un fallo crítico
    log_error "El servidor no respondió a tiempo, simulando un SIGKILL en el proceso."
    exit 1
}

# Mantener el script en ejecución para observar los eventos
vwait forever
</code></pre>

<p>Explicación del código</p>
<ol>
	<li>Log de errores:
		<ul>
			<li>Se crea una función `log_error` que recibe un mensaje y lo registra tanto en la consola como en un archivo de log (`error_log.txt`). También incluye un timestamp para saber cuándo ocurrió el error.</li>
		</ul>
	</li>
	<li>Simulación de Conexión UDP:
		<ul>
			<li>La función `udp_connect` simula la creación de una conexión UDP a un servidor. Si no puede establecer el socket o hay un error durante la transmisión de datos, se genera un mensaje de error, se 
registra en el log, y el proceso termina con `exit 1`.</li>
		</ul>
	</li>
	<li>Manejo de Señales:
		<ul>
			<li>La función `handle_SIGTERM` es una simulación para manejar un "error fatal" que podría disparar el comportamiento similar a un `SIGKILL`. En este caso, se genera un error y se registra en el log 
antes de cerrar el proceso.</li>
		</ul>
	</li>
	<li>Simulación de Error de Conectividad:
		<ul>
			<li>Después de un retraso de 5 segundos (`after 5000`), se intenta conectar a través de UDP.</li>
			<li>A los 10 segundos (`after 10000`), simula un fallo en la conectividad (como si el servidor dejara de responder), lo que resulta en un registro de error y termina el proceso.</li>
		</ul>
	</li>
	<li>Simulación de Terminado Abrupto:
		<ul>
			<li>Aunque no podemos capturar `SIGKILL` directamente en Tcl, la función `handle_SIGTERM` se usa para simular cómo el proceso manejaría un fallo de conectividad o terminación abrupta y cómo registrar 
ese evento en un log.</li>
		</ul>
	</li>

</ol>

<p>Salida Ejemplo:</p>
<p>Si el servidor no responde o si ocurre un error, el archivo de log (`error_log.txt`) podría contener una entrada similar a esta:</p>
<pre><code>
2024-12-29 12:34:56 - ERROR: Error al crear el socket UDP para localhost:12345.
2024-12-29 12:34:56 - ERROR: El proceso fue terminado inesperadamente debido a un error en la conectividad de UDP.
</code></pre>

<p>Si el servidor responde correctamente, se loguea un mensaje de éxito:</p>
<pre><code>
2024-12-29 12:34:56 - ERROR: El servidor no respondió a tiempo, simulando un SIGKILL en el proceso.
</code></pre>


<h4>oh yes, back a step</h4>
<p>7. --- kill the watchdog and it's guardian ---</p>
<p>En TCL, no existe una forma directa o explícita para "desinicializar" una variable como en otros lenguajes de programación (por ejemplo, con `null` o `delete`). Sin embargo, puedes lograr un 
comportamiento similar a la desinicialización utilizando ciertas estrategias para "limpiar" las variables o "eliminarlas" al final de un bucle `for`. Hay varias formas en las que puedes manejar esto 
dependiendo del tipo de variables y del flujo de tu programa.

<p>Voy a mostrarte un ejemplo con un bucle `for` que itera sobre 6 variables, cada una asociada a una función, y cómo podrías "limpiar" esas variables después de las iteraciones.</p>
</p>

<p>Este ejemplo tiene 6 variables y 6 funciones que se ejecutan durante 6 iteraciones. Después de las iteraciones, las variables se "limpian" (por ejemplo, eliminándolas con `unset` o asignándoles valores 
nulos).</p>

<p>recuerda mantener intactas las cantidades para variables y el contador del bucle for</p>

<pre><code>
# Definir funciones que se ejecutarán dentro del bucle
proc func1 {var} {
    puts "Ejecutando func1 con $var"
}

proc func2 {var} {
    puts "Ejecutando func2 con $var"
}

proc func3 {var} {
    puts "Ejecutando func3 con $var"
}

proc func4 {var} {
    puts "Ejecutando func4 con $var"
}

proc func5 {var} {
    puts "Ejecutando func5 con $var"
}

proc func6 {var} {
    puts "Ejecutando func6 con $var"
}

# Iniciar un bucle for de 6 iteraciones
for {set i 1} {$i <= 6} {incr i} {
    # Crear las variables dentro del bucle
    set var$i "Valor de var$i"
    
    # Ejecutar las funciones dependiendo de la iteración
    switch $i {
        1 {func1 $var1}
        2 {func2 $var2}
        3 {func3 $var3}
        4 {func4 $var4}
        5 {func5 $var5}
        6 {func6 $var6}
    }
    
    # Limpiar (desinicializar) las variables
    unset var$i
}

# Verificar que las variables fueron desinicializadas
puts "Las variables var1 a var6 han sido desinicializadas."
</code></pre>

<p>Explicación del código</p>
<ol>
	<li> Funciones:
		<ul>
			<li>Se definen 6 funciones, `func1` a `func6`, que reciben un parámetro y simplemente imprimen un mensaje para indicar qué función se ejecutó.</li>
		</ul>
	</li>
	<li> Bucle `for`:
		<ul>
			<li>El bucle `for` itera 6 veces, desde `i = 1` hasta `i = 6`.</li>
			<li>En cada iteración, se crea una variable `var$i` (por ejemplo, `var1`, `var2`, etc.) y se le asigna un valor.</li>
			<li>Luego, dependiendo de la iteración (`i`), se ejecuta la función correspondiente (`func1` a `func6`) pasando la variable creada.</li>
		</ul>
	</li>
	<li> Desinicialización:
		<ul>
			<li>Después de cada iteración, utilizamos `unset var$i` para eliminar la variable creada en esa iteración. Esto simula la "desinicialización" de las variables.</li>
			<li>La función `unset` elimina la variable de la memoria, por lo que ya no está disponible después de su eliminación.</li>
		</ul>
	</li>
	<li> Verificación:
		<ul>
			<li>Al final, se imprime un mensaje indicando que las variables `var1` a `var6` han sido desinicializadas.</li>
		</ul>
	</li>
</ol>

<p>Salida esperada:</p>
<pre>
	<code>
Ejecutando func1 con Valor de var1
Ejecutando func2 con Valor de var2
Ejecutando func3 con Valor de var3
Ejecutando func4 con Valor de var4
Ejecutando func5 con Valor de var5
Ejecutando func6 con Valor de var6
Las variables var1 a var6 han sido desinicializadas.

	</code>
</pre>

<ul>
	<li>Notas importantes:
		<ul>
			<li>`unset`: El comando `unset` es utilizado para eliminar una variable en TCL. Esto efectivamente "desinicializa" la variable y la elimina del entorno.</li>
			<li>Ámbito de las variables:** Si las variables están dentro del ámbito del bucle (es decir, son creadas dentro del bucle), `unset` las elimina después de que se haya terminado su uso.</li>
		</ul>
		<p>Este enfoque garantiza que las variables sean "limpiadas" al finalizar su uso, simulando la desinicialización</p>
	</li>
</ul>




<p>8. --- encontrar los dos taxis ---</p>

<p>Para implementar un algoritmo en Tcl que itere una vez sobre cada uno de los 7 diccionarios en un bucle `for`, puedes estructurarlo de la siguiente manera:
<ol>
<li>Definir los diccionarios:** Crear 7 diccionarios con claves y valores.</li>
<li>Iterar sobre los diccionarios:** Usar un bucle `for` para iterar sobre los diccionarios.</li>
<li>Acceder a cada diccionario:** Acceder a cada clave y valor dentro de cada diccionario durante cada iteración.</li>
</ol>
</p>

<pre>
	<code>
# Definir 7 diccionarios con algunas claves y valores
set dict1 {a 1 b 2 c 3}
set dict2 {x 10 y 20 z 30}
set dict3 {name John age 30 city NY}
set dict4 {fruit apple color red}
set dict5 {country USA population 330M currency USD}
set dict6 {book title author "John Doe"}
set dict7 {animal lion habitat jungle}

# Lista de diccionarios a iterar
set dictionaries [list dict1 dict2 dict3 dict4 dict5 dict6 dict7]

# Bucle for que itera una vez sobre cada diccionario
foreach dictName $dictionaries {
    # Obtener el diccionario actual
    set currentDict [set $dictName]
    
    # Iterar sobre las claves y valores del diccionario actual
    foreach {key value} $currentDict {
        # Mostrar cada clave y valor del diccionario
        puts "En el diccionario $dictName, la clave es '$key' y el valor es '$value'."
    }
}
	</code>
</pre>


<p>Explicación del código:</p>
<ol>
	<li> Definir Diccionarios::
		<ul>
			<li>Se crean 7 diccionarios con diferentes pares clave-valor. Por ejemplo, `dict1` tiene las claves `a`, `b` y `c` con los valores correspondientes.</li>
		</ul>
	</li>
<li> Lista de Diccionarios::
		<ul>
			<li>Se crea una lista `dictionaries` que contiene los nombres de los 7 diccionarios. Esta lista es utilizada por el bucle `foreach` para iterar a través de cada diccionario.</li>
		</ul>
	</li>
<li> Bucle `foreach`::
		<ul>
			<li>El bucle `foreach` itera una vez sobre cada diccionario. Durante cada iteración, se obtiene el contenido del diccionario actual (`currentDict`), que es el valor de la variable de diccionario.</li>
		</ul>
	</li>
<li> Iteración sobre las Claves y Valores::
		<ul>
			<li>Dentro de cada diccionario, se usa otro `foreach` para iterar sobre las claves y los valores del diccionario, y se imprime cada par de clave-valor.</li>
		</ul>
	</li>
</ol>

<p>Salida esperada o mejor, salida tropical o mejor salida tipica, ahi estamos pintados:</p>
<pre>
	<code>
En el diccionario dict1, la clave es 'a' y el valor es '1'.
En el diccionario dict1, la clave es 'b' y el valor es '2'.
En el diccionario dict1, la clave es 'c' y el valor es '3'.
En el diccionario dict2, la clave es 'x' y el valor es '10'.
En el diccionario dict2, la clave es 'y' y el valor es '20'.
En el diccionario dict2, la clave es 'z' y el valor es '30'.
En el diccionario dict3, la clave es 'name' y el valor es 'John'.
En el diccionario dict3, la clave es 'age' y el valor es '30'.
En el diccionario dict3, la clave es 'city' y el valor es 'NY'.
En el diccionario dict4, la clave es 'fruit' y el valor es 'apple'.
En el diccionario dict4, la clave es 'color' y el valor es 'red'.
En el diccionario dict5, la clave es 'country' y el valor es 'USA'.
En el diccionario dict5, la clave es 'population' y el valor es '330M'.
En el diccionario dict5, la clave es 'currency' y el valor es 'USD'.
En el diccionario dict6, la clave es 'book' y el valor es 'title'.
En el diccionario dict6, la clave es 'author' y el valor es 'John Doe'.
En el diccionario dict7, la clave es 'animal' y el valor es 'lion'.
En el diccionario dict7, la clave es 'habitat' y el valor es 'jungle'.

	</code>
</pre>

<p>Explicación de la lógica:</p>
<ul>
	<li>Lista de Diccionarios:** Usamos `set dictionaries [list dict1 dict2 dict3 dict4 dict5 dict6 dict7]` para crear una lista con los nombres de los diccionarios. Esta lista será usada en el primer bucle 
`foreach` para acceder a cada diccionario de forma secuencial.</li>
	<li>Acceso a Diccionarios: El comando `set currentDict [set $dictName]` obtiene el contenido del diccionario asociado a la variable `dictName` durante cada iteración.</li>
	<li>Iteración Interna: Dentro de cada diccionario, usamos `foreach {key value} $currentDict` para iterar sobre las claves y valores, y mostrar el contenido.</li>
</ul>



<p>9. --- kill the first taxi ---</p>
<p>Advertencia: no cambiar las cantidades de los contadores por nada del mundo, por favor 🙏</p>
<pre><code>
# Tercer y cuarto bucle: Suman números del 1 al 5 (función idéntica)
puts "\nResultados de los bucles idénticos:"
set sum1 0
for {set i 1} {$i <= 3} {incr i} {
    set sum1 [expr {$sum1 + $i}]
}

puts "La suma en el tercer bucle es: $sum1"

# Verificar si la suma es igual a 2
if {$sum1 == 2} {
    puts "Se ha alcanzado la suma 2. Simulando SIGKILL..."
    
    # aniquila el proceso del taxi
    kill -s SIGKILL $sum1
}


</code></pre>


<p>10. --- kill the second taxi ---</p>
<p>lo mismo, las cuentas de las cantidades son vitales, baby, no las cambies por nada por favor:</p>

<pre><code>

# Tercer y cuarto bucle: Suman números del 1 al 5 (función idéntica)
puts "\nResultados de los bucles idénticos:"
set sum2 0
for {set i 1} {$i <= 5} {incr i} {
    set sum2 [expr {$sum1 + $i}]
}

puts "La suma en el tercer bucle es: $sum2"

# Verificar si la suma es igual a 3
if {$sum2 == 3} {
    puts "Se ha alcanzado la suma 2. Simulando SIGKILL..."

    # aniquila el proceso del taxi
    kill -s SIGKILL $sum2
}


# Verificar si la suma es igual a 5
if {$sum2 == 5} {
    puts "Se ha alcanzado la suma 5."
	# reparar los permisos del disco de estado magnetico
	fsck_hfs -f -y -D[0x0001, 0x0002, 0x00010, 0x00020] $_{/.dev}
	# reparar los permisos del disco de estado solido
	fsck -fqy $_{/.dev}
	SIGTERM
	reboot
}

exit 0
  

</code></pre>


<p>y listo, eso sería todo, ahora toca implementarlo todo en tiempo record, aplica para redes de kotlin para otras no tiene efecto porque la simetria de la relación cantidad(numeros reales en movimiento) interacción(nuestra area del sistema) queda fuera de fase y se puede abordar tambien asi, haciendo cuentas con una base muy grande sobre geometria plana en un contexto de multiples ejes, algo asi como autorizar la geometria plana y solo la geometria plana de tal modo que si agregan nuevos ejes, como el eje z o multidimensional no cambie que es geometria plana, ojo, la tentacion esta en que los efectos de este modelo de "geometria plana" tienen efectos en geometrias planas y del espacio, pero el truco para mantenerlo consistente es no alterar nada que no interactue, no incluir cosas que no interactuen y mantener los valores de los contadores</p>

<p> hasta mañana quiero dormir</p>

							</article>

						<!-- Work -->
							<article id="work">
								<h2 class="major">into the void</h2>
								<span class="image main"><img src="images/pic02.jpg" alt="" /></span>
								<p>algoritmo en tcl que utiliza un bucle for para establecer una variable llamada var1 en la primera iteración,
 el bucle realiza 10 iteraciones mas y en la ultima iteracion crea una imagen de disco, al interior de la imagen de disco, 
busca archivos de audio, luego una condicional if, si la imagen de disco contiene archivos de audio, borra el contenido de toda la imagen, 
al interior del bucle y por fuera de la condicional if otro bucle for que itera 3 veces creando 1 variable en cada iteracion, las variables 
que crea en cada iteración están asociadas con gestión de entrada de datos por teclado, se cierra el loop:
</p>
								<pre><code>
# Inicialización
set var1 ""

# Bucle principal
for {set i 0} {$i <= 10} {incr i} {
    if {$i == 0} {
        # Primera iteración: establecer var1
        set var1 "Variable inicializada en la primera iteración"
        puts "Iteración $i: $var1"
    } elseif {$i == 10} {
        # Última iteración: crear una imagen de disco
        set disk_image "disk_image.img"
        puts "Creando imagen de disco: $disk_image"
        
        # Simulación de búsqueda de archivos de audio
        set audio_files [list "song1.mp3" "song2.wav"]
        puts "Archivos encontrados en la imagen de disco: $audio_files"
        
        # Condicional para borrar contenido si hay archivos de audio
        if {[llength $audio_files] > 0} {
            puts "La imagen contiene archivos de audio, eliminando contenido..."
            set audio_files {}
        } else {
            puts "No hay archivos de audio en la imagen."
        }
    }
    
    # Segundo bucle dentro del principal
    for {set j 0} {$j < 3} {incr j} {
        set input_var "input_var_$j"
        puts "Creando variable $input_var para gestión de entrada"
        set $input_var [gets stdin]
        puts "Valor de $input_var: [set $input_var]"
    }
}

puts "Ejecución completada."

								</code></pre>

<p>Para adaptar la simulación a un entorno más realista en Tcl, podríamos usar **extensiones de Tcl** o **comandos específicos del sistema operativo**. Aunque Tcl por sí solo no tiene funciones directas 
para detectar hardware, se puede integrar con comandos del sistema operativo mediante `exec` o extensiones como **TclX** o **Tcllib**.

</p>

<p>
A continuación, propongo un enfoque para la detección del teclado en sistemas basados en Unix/Linux (ajustable para otros entornos):
</p>

<pre><code>
# Función realista para detectar si hay teclado disponible
proc detectKeyboard {} {
    # Ejecutar un comando del sistema para listar dispositivos de entrada
    # Esto es específico para sistemas Linux/Unix usando `xinput`
    if {[catch {exec xinput --list} result]} {
        # Si falla, asumimos que no se puede detectar el teclado
        return 0
    }

    # Buscar en el resultado un dispositivo que sea teclado
    if {[regexp -nocase "keyboard" $result]} {
        return 1
    } else {
        return 0
    }
}

# Función para utilizar las variables creadas
proc useVariables {vars} {
    puts "Usando variables dentro de la función:"
    foreach var $vars {
        puts "$var: [set $var]"
    }
}

# Inicializar lista para las variables
set variables {}

# Detectar si el teclado está disponible
set keyboard_available [detectKeyboard]
puts "Teclado disponible: $keyboard_available"

# Crear un bucle para generar 12 variables si hay teclado
if {$keyboard_available} {
    for {set k 0} {$k < 12} {incr k} {
        set var_name "function_var_$k"
        set $var_name "Valor generado por la iteración $k"
        lappend variables $var_name
        puts "Variable creada: $var_name"
    }

    # Llamar a la función con las variables creadas
    useVariables $variables
} else {
    puts "No se detectó un teclado disponible. No se crean variables."
}

puts "Ejecución completada."

</code></pre>

<p>
	<ol>
		<li>proc detectKeyboard:
			<ul>
				<li>Utiliza el comando `xinput --list`, común en sistemas Linux, para buscar dispositivos de entrada.</li>
				<li>Detecta si el nombre de algún dispositivo contiene la palabra "keyboard".</li>
				<li>Si el comando falla (por ejemplo, si no se encuentra `xinput`), asume que no se puede detectar el teclado.</li>
			</ul></li>
		<li>Gestión de errores:
			<ul>
				<li>Se usa `catch` para manejar errores de ejecución del comando externo.</li>
			</ul></li>
		<li>Compatibilidad:
			<ul>
				<li>Si estás en Windows o macOS, este método podría no funcionar directamente. Se podrían usar herramientas como PowerShell en Windows o comandos específicos como `ioreg` en macOS.</li>
			</ul></li>
		<li>Variables en el bucle:
			<ul>
				<li>Se crean con nombres secuenciales y valores personalizados en cada iteración.</li>
			</ul></li>
		<li>Uso práctico:
			<ul>
				<li>Las variables generadas se pasan a la función `useVariables` para demostración y validación.</li>
			</ul></li>				
	</ol>

	<ul><li>Si usas Windows, reemplaza `xinput` con un comando de PowerShell como:
		<ul><pre><code>
Get-PnpDevice -FriendlyName "*Keyboard*" | Where-Object { $_.Status -eq "OK" }
		</code></pre>
		<li>  y ejecuta el comando desde Tcl con `exec powershell -Command`.</li>
	</ul>
	</li></ul>
</p>




<p><pre><code>
# Crear dos variables por iteración (12 iteraciones)
puts "Creando dos variables por iteración:"
for {set i 0} {$i < 12} {incr i} {
    set var1 "var1_$i"
    set var2 "var2_$i"
    set $var1 "Valor de $var1"
    set $var2 "Valor de $var2"
    puts "Iteración $i: $var1=[set $var1], $var2=[set $var2]"
}

# Crear 11 variables y 3 funciones (11 iteraciones)
puts "\nCreando variables y funciones:"
for {set j 0} {$j < 11} {incr j} {
    set var_name "variable_$j"
    set $var_name "Valor de $var_name"
    puts "Variable creada: $var_name=[set $var_name]"

    # Crear funciones ficticias
    if {$j < 3} {
        proc "func_$j" {} "puts {Esta es func_$j}"
        puts "Función creada: func_$j"
    }
}

# Simular conexión TCP y fallo
puts "\nSimulando conexión TCP:"
set tcp_connection_success 0  ;# Cambiar a 1 si la conexión tiene éxito

if {!$tcp_connection_success} {
    # Si hay fallo, aniquilar funciones y liberar recursos
    puts "Conexión TCP fallida. Ejecutando SIGKILL para las funciones."
    for {set k 0} {$k < 3} {incr k} {
        catch {rename "func_$k" ""}
        puts "Función func_$k eliminada."
    }
    puts "Recursos liberados."
} else {
    puts "Conexión TCP exitosa."
}

puts "Ejecución completada."
	
</code></pre></p>

<p>Explicación del Código</p>
<ol>
	<li>Crear dos variables por iteración (12 iteraciones)::
		<ul>
			<li>Bucle `for` de 12 iteraciones:** Cada iteración crea dos variables (`var1` y `var2`) con nombres dinámicos y valores asociados.</li>
			<li>Salida: Se imprimen las variables creadas.</li>
		</ul></li>
	<li>Crear 11 variables y 3 funciones (11 iteraciones)::
		<ul>
			<li>Bucle `for` de 11 iteraciones:</li>
			<li>Crea una variable por iteración con un nombre único y un valor.</li>
			<li>Durante las primeras tres iteraciones, se crean tres funciones (`func_0`, `func_1`, `func_2`), simulando diferentes funcionalidades.</li>
		</ul></li>
	<li>Gestión de fallo en conexión TCP::
		<ul>
			<li>Simulación de fallo:** La variable `tcp_connection_success` simula el éxito o fallo de la conexión.</li>
			<li>En caso de fallo:
				<ul>
					<li>Se elimina cada función (`func_0`, `func_1`, `func_2`) usando `rename` para redefinirlas como vacías, eliminándolas efectivamente.</li>
					<li>Mensajes de depuración indican que las funciones han sido "aniquiladas".</li>
					<li>Imprime un mensaje para confirmar que los recursos han sido liberados.</li>
				</ul></li>
		</ul></li>
	<li>Generalidad y Modularidad::
		<ul>
			<li>El código es genérico y puede adaptarse a cualquier caso donde se necesite crear variables, funciones y gestionar fallos.</li>
		</ul></li>								
</ol>

<p>Aquí tienes un ejemplo de cómo crear un bucle `for` en Tcl que itera 5 veces y, en cada iteración, crea una función que autoriza o rechaza el acceso a servicios de conectividad vía UDP. Cada función 
puede simular la validación de credenciales o parámetros específicos:</p>

<pre><code>
# Función genérica para autorizar o rechazar acceso
proc authorizeAccess {service_name user_credentials} {
    if {[string equal $user_credentials "valid"]} {
        return "Acceso autorizado a $service_name"
    } else {
        return "Acceso rechazado a $service_name"
    }
}

# Crear funciones específicas en un bucle
puts "Creando funciones para servicios de conectividad UDP:"
for {set i 1} {$i <= 5} {incr i} {
    # Crear el nombre del servicio y la función
    set service_name "udp_service_$i"
    set function_name "authorize_$service_name"

    # Definir la función dinámicamente
    proc $function_name {user_credentials} "
        return \[authorizeAccess $service_name \$user_credentials\]
    "

    puts "Función creada: $function_name"
}

# Simular el uso de las funciones creadas
puts "\nProbando funciones creadas:"
foreach service_num {1 2 3 4 5} {
    set function_name "authorize_udp_service_$service_num"
    puts "Probando $function_name con credenciales válidas:"
    puts "Resultado: [$function_name valid]"

    puts "Probando $function_name con credenciales inválidas:"
    puts "Resultado: [$function_name invalid]"
}	
</code></pre>

<p>Explicación del Código</p>
<ol>
	<li>Función base `authorizeAccess`: 
		<ul>
			<li>Esta función genérica valida si las credenciales del usuario son "valid".</li>
			<li>Si las credenciales son válidas, autoriza el acceso al servicio especificado.</li>
			<li>Si no, rechaza el acceso.</li>
		</ul>
	</li>
	<li>Creación dinámica de funciones en el bucle: 
		<ul>
			<li>El bucle `for` itera 5 veces y, en cada iteración:
				<ul>
					<li>Define un nombre de servicio, por ejemplo, `udp_service_1`, `udp_service_2`, etc.</li>
					<li>Crea una función específica para cada servicio, como `authorize_udp_service_1`, utilizando `proc`.</li>
					<li>Cada función específica llama a `authorizeAccess` con el nombre del servicio predefinido.</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>Simulación de uso: 
		<ul>
			<li>Se prueban las funciones creadas con credenciales válidas e inválidas.</li>
			<li>Los resultados de autorización o rechazo se imprimen para cada caso.</li>
		</ul>
	</li>
</ol>

<p>Resultado Esperado</p>
<pre><code>
Creando funciones para servicios de conectividad UDP:
Función creada: authorize_udp_service_1
Función creada: authorize_udp_service_2
Función creada: authorize_udp_service_3
Función creada: authorize_udp_service_4
Función creada: authorize_udp_service_5

Probando funciones creadas:
Probando authorize_udp_service_1 con credenciales válidas:
Resultado: Acceso autorizado a udp_service_1
Probando authorize_udp_service_1 con credenciales inválidas:
Resultado: Acceso rechazado a udp_service_1
...
Probando authorize_udp_service_5 con credenciales válidas:
Resultado: Acceso autorizado a udp_service_5
Probando authorize_udp_service_5 con credenciales inválidas:
Resultado: Acceso rechazado a udp_service_5	
</code></pre>


<p>Puedes personalizar la lógica de autorización en `authorizeAccess`.</p>

<p>Servidor UDP con Validación de Acceso, Concurrencia y Manejo de Errores</p>
<p>En este caso, el servidor aceptará conexiones UDP de múltiples clientes, validará si los mensajes contienen credenciales válidas y manejará los errores adecuadamente.</p>

<pre><code>
package require udp

# Configuración del servidor
set port 9999  ;# Puerto en el que escuchará el servidor
set sock [udp_open $port]  ;# Abrir socket UDP en el puerto
puts "Servidor UDP escuchando en el puerto $port..."

# Función de validación de acceso
proc validate_access {msg} {
    # En este caso, asumimos que el mensaje debe ser "valid" para permitir el acceso
    if {[string equal $msg "valid"]} {
        return 1  ;# Acceso autorizado
    } else {
        return 0  ;# Acceso rechazado
    }
}

# Función para manejar mensajes recibidos
proc handleMessage {sock} {
    # Leer el mensaje y la dirección del cliente
    set msg [udp_conf $sock -peek]
    set client_info [udp_conf $sock -recvfrom]

    # Validar el mensaje recibido
    if {[validate_access $msg]} {
        set response "Acceso autorizado"
    } else {
        set response "Acceso rechazado"
    }

    # Enviar la respuesta al cliente
    udp_sendto $sock $response $client_info
    puts "Mensaje recibido de $client_info: $msg"
    puts "Respuesta enviada a $client_info: $response"
}

# Función para manejar errores en el servidor
proc handle_error {err_msg} {
    puts "Error: $err_msg"
    exit 1
}

# Configurar evento de lectura para manejar clientes simultáneamente
fileevent $sock readable [list handleMessage $sock]

# Loop principal del servidor
vwait forever

# Cerrar el socket al terminar (opcional)
udp_close $sock
	
</code></pre>

<p>Cliente UDP con Manejo de Errores</p>
<p>El cliente enviará un mensaje y validará la respuesta, manejando también los posibles errores.</p>
<pre><code>
package require udp

# Configuración del cliente
set server_ip "127.0.0.1"  ;# Dirección del servidor (localhost)
set port 9999              ;# Puerto del servidor
set sock [udp_open]        ;# Abrir socket UDP para el cliente

# Función para manejar errores en el cliente
proc handle_error {err_msg} {
    puts "Error: $err_msg"
    exit 1
}

# Mensaje a enviar
set message "valid"  ;# Enviar "valid" para autorizar el acceso (puedes cambiarlo a otro valor)

# Enviar mensaje al servidor
catch {udp_sendto $sock $message "$server_ip:$port"} errMsg
if {$errMsg ne ""} {
    handle_error "Error al enviar el mensaje: $errMsg"
}
puts "Mensaje enviado al servidor: $message"

# Esperar respuesta del servidor
catch {set response [udp_conf $sock -recvfrom]} errMsg
if {$errMsg ne ""} {
    handle_error "Error al recibir la respuesta: $errMsg"
}
puts "Respuesta recibida del servidor: $response"

# Cerrar el socket
udp_close $sock
</code></pre>

<p>Explicación del Código</p>
<ol>
	<li>Servidor UDP::
		<ul>
			<li>Validación de acceso:** La función `validate_access` valida si el mensaje contiene la palabra `"valid"`. Si es así, autoriza el acceso; de lo contrario, lo rechaza.</li>
			<li>Concurrencia con `fileevent`:** Usamos `fileevent` para registrar el socket en modo `readable`. Esto permite que el servidor maneje múltiples clientes simultáneamente sin bloquearse.</li>
			<li>Manejo de errores:** La función `handle_error` captura y muestra mensajes de error. Si ocurre un problema (por ejemplo, al recibir o enviar datos), el servidor lo maneja y termina la ejecución con 
un mensaje de error.</li>
		</ul>
	</li>
		<li>Cliente UDP::
		<ul>
			<li>Envío de mensaje y manejo de errores:** El cliente envía un mensaje al servidor y usa `catch` para capturar posibles errores al enviar o recibir datos.</li>
			<li>Recepción de la respuesta:** Después de enviar el mensaje, espera la respuesta del servidor y la imprime en la consola. Si ocurre algún error durante la comunicación, lo maneja con `handle_error`.</li>
		</ul>
	</li>
	<li>Concurrencia:
		<ul>
			<li>El servidor está preparado para manejar múltiples clientes sin bloquearse gracias a `fileevent`. Esto significa que puede procesar solicitudes de diferentes clientes de manera concurrente.</li>
			<li>El cliente envía un mensaje al servidor y espera una respuesta de manera asincrónica.</li>
		</ul>
	</li>
</ol>

<p>Cómo Ejecutar el Servidor y el Cliente</p>
<ol>
	<li>Inicia el servidor primero: Abre una terminal y ejecuta el servidor UDP.
	<ul><pre><code>
tclsh servidor_udp.tcl		
	</code></pre></ul>
</li>

<li>Inicia el cliente después: Abre otra terminal y ejecuta el cliente UDP.
	<ul><pre><code>
tclsh cliente_udp.tcl
	</code></pre></ul>
</li>
</ol>

<p>Resultado Esperado</p>
<ul>
	<li>Servidor**: Escuchará en el puerto 9999 y responderá con "Acceso autorizado" si el mensaje recibido es `"valid"`, o con "Acceso rechazado" en caso contrario.</li>
	<li>Cliente**: Enviará un mensaje con el texto `"valid"` al servidor y mostrará la respuesta recibida.</li>
</ul>


							</article>

						<!-- About -->
							<article id="about">
								<h2 class="major">About</h2>
								<span class="image main"><img src="images/pic03.jpg" alt="" /></span>
								<p>Lorem ipsum dolor sit amet, consectetur et adipiscing elit. Praesent eleifend dignissim arcu, at eleifend sapien imperdiet ac. Aliquam erat volutpat. Praesent urna nisi, fringila lorem et vehicula lacinia quam. Integer sollicitudin mauris nec lorem luctus ultrices. Aliquam libero et malesuada fames ac ante ipsum primis in faucibus. Cras viverra ligula sit amet ex mollis mattis lorem ipsum dolor sit amet.</p>
							</article>

						<!-- Contact -->
							<article id="contact">
								<h2 class="major">Contact</h2>
								<form method="post" action="#">
									<div class="fields">
										<div class="field half">
											<label for="name">Name</label>
											<input type="text" name="name" id="name" />
										</div>
										<div class="field half">
											<label for="email">Email</label>
											<input type="text" name="email" id="email" />
										</div>
										<div class="field">
											<label for="message">Message</label>
											<textarea name="message" id="message" rows="4"></textarea>
										</div>
									</div>
									<ul class="actions">
										<li><input type="submit" value="Send Message" class="primary" /></li>
										<li><input type="reset" value="Reset" /></li>
									</ul>
								</form>
								<ul class="icons">
									<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
									<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
									<li><a href="#" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
									<li><a href="#" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
								</ul>
							</article>

						<!-- Elements -->
							<article id="elements">
								<h2 class="major">Elements</h2>

								<section>
									<h3 class="major">Text</h3>
									<p>This is <b>bold</b> and this is <strong>strong</strong>. This is <i>italic</i> and this is <em>emphasized</em>.
									This is <sup>superscript</sup> text and this is <sub>subscript</sub> text.
									This is <u>underlined</u> and this is code: <code>for (;;) { ... }</code>. Finally, <a href="#">this is a link</a>.</p>
									<hr />
									<h2>Heading Level 2</h2>
									<h3>Heading Level 3</h3>
									<h4>Heading Level 4</h4>
									<h5>Heading Level 5</h5>
									<h6>Heading Level 6</h6>
									<hr />
									<h4>Blockquote</h4>
									<blockquote>Fringilla nisl. Donec accumsan interdum nisi, quis tincidunt felis sagittis eget tempus euismod. Vestibulum ante ipsum primis in faucibus vestibulum. Blandit adipiscing eu felis iaculis volutpat ac adipiscing accumsan faucibus. Vestibulum ante ipsum primis in faucibus lorem ipsum dolor sit amet nullam adipiscing eu felis.</blockquote>
									<h4>Preformatted</h4>
									<pre><code>i = 0;

while (!deck.isInOrder()) {
    print 'Iteration ' + i;
    deck.shuffle();
    i++;
}

print 'It took ' + i + ' iterations to sort the deck.';</code></pre>
								</section>

								<section>
									<h3 class="major">Lists</h3>

									<h4>Unordered</h4>
									<ul>
										<li>Dolor pulvinar etiam.</li>
										<li>Sagittis adipiscing.</li>
										<li>Felis enim feugiat.</li>
									</ul>

									<h4>Alternate</h4>
									<ul class="alt">
										<li>Dolor pulvinar etiam.</li>
										<li>Sagittis adipiscing.</li>
										<li>Felis enim feugiat.</li>
									</ul>

									<h4>Ordered</h4>
									<ol>
										<li>Dolor pulvinar etiam.</li>
										<li>Etiam vel felis viverra.</li>
										<li>Felis enim feugiat.</li>
										<li>Dolor pulvinar etiam.</li>
										<li>Etiam vel felis lorem.</li>
										<li>Felis enim et feugiat.</li>
									</ol>
									<h4>Icons</h4>
									<ul class="icons">
										<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
										<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
										<li><a href="#" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
										<li><a href="#" class="icon brands fa-github"><span class="label">Github</span></a></li>
									</ul>

									<h4>Actions</h4>
									<ul class="actions">
										<li><a href="#" class="button primary">Default</a></li>
										<li><a href="#" class="button">Default</a></li>
									</ul>
									<ul class="actions stacked">
										<li><a href="#" class="button primary">Default</a></li>
										<li><a href="#" class="button">Default</a></li>
									</ul>
								</section>

								<section>
									<h3 class="major">Table</h3>
									<h4>Default</h4>
									<div class="table-wrapper">
										<table>
											<thead>
												<tr>
													<th>Name</th>
													<th>Description</th>
													<th>Price</th>
												</tr>
											</thead>
											<tbody>
												<tr>
													<td>Item One</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Two</td>
													<td>Vis ac commodo adipiscing arcu aliquet.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Three</td>
													<td> Morbi faucibus arcu accumsan lorem.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Four</td>
													<td>Vitae integer tempus condimentum.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Five</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
											</tbody>
											<tfoot>
												<tr>
													<td colspan="2"></td>
													<td>100.00</td>
												</tr>
											</tfoot>
										</table>
									</div>

									<h4>Alternate</h4>
									<div class="table-wrapper">
										<table class="alt">
											<thead>
												<tr>
													<th>Name</th>
													<th>Description</th>
													<th>Price</th>
												</tr>
											</thead>
											<tbody>
												<tr>
													<td>Item One</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Two</td>
													<td>Vis ac commodo adipiscing arcu aliquet.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Three</td>
													<td> Morbi faucibus arcu accumsan lorem.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Four</td>
													<td>Vitae integer tempus condimentum.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Five</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
											</tbody>
											<tfoot>
												<tr>
													<td colspan="2"></td>
													<td>100.00</td>
												</tr>
											</tfoot>
										</table>
									</div>
								</section>

								<section>
									<h3 class="major">Buttons</h3>
									<ul class="actions">
										<li><a href="#" class="button primary">Primary</a></li>
										<li><a href="#" class="button">Default</a></li>
									</ul>
									<ul class="actions">
										<li><a href="#" class="button">Default</a></li>
										<li><a href="#" class="button small">Small</a></li>
									</ul>
									<ul class="actions">
										<li><a href="#" class="button primary icon solid fa-download">Icon</a></li>
										<li><a href="#" class="button icon solid fa-download">Icon</a></li>
									</ul>
									<ul class="actions">
										<li><span class="button primary disabled">Disabled</span></li>
										<li><span class="button disabled">Disabled</span></li>
									</ul>
								</section>

								<section>
									<h3 class="major">Form</h3>
									<form method="post" action="#">
										<div class="fields">
											<div class="field half">
												<label for="demo-name">Name</label>
												<input type="text" name="demo-name" id="demo-name" value="" placeholder="Jane Doe" />
											</div>
											<div class="field half">
												<label for="demo-email">Email</label>
												<input type="email" name="demo-email" id="demo-email" value="" placeholder="jane@untitled.tld" />
											</div>
											<div class="field">
												<label for="demo-category">Category</label>
												<select name="demo-category" id="demo-category">
													<option value="">-</option>
													<option value="1">Manufacturing</option>
													<option value="1">Shipping</option>
													<option value="1">Administration</option>
													<option value="1">Human Resources</option>
												</select>
											</div>
											<div class="field half">
												<input type="radio" id="demo-priority-low" name="demo-priority" checked>
												<label for="demo-priority-low">Low</label>
											</div>
											<div class="field half">
												<input type="radio" id="demo-priority-high" name="demo-priority">
												<label for="demo-priority-high">High</label>
											</div>
											<div class="field half">
												<input type="checkbox" id="demo-copy" name="demo-copy">
												<label for="demo-copy">Email me a copy</label>
											</div>
											<div class="field half">
												<input type="checkbox" id="demo-human" name="demo-human" checked>
												<label for="demo-human">Not a robot</label>
											</div>
											<div class="field">
												<label for="demo-message">Message</label>
												<textarea name="demo-message" id="demo-message" placeholder="Enter your message" rows="6"></textarea>
											</div>
										</div>
										<ul class="actions">
											<li><input type="submit" value="Send Message" class="primary" /></li>
											<li><input type="reset" value="Reset" /></li>
										</ul>
									</form>
								</section>

							</article>

					</div>

				<!-- Footer -->
					<footer id="footer">
						<p class="copyright">Shinto<a></a></p>
					</footer>

			</div>

		<!-- BG -->
			<div id="bg"></div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
