<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="title" content="Mega Doll" />
    <meta name="description" content="music for broken doll aesthetic accidents, evident pizza stains, more accidents and oh yes forgot about music for unintended consequences" />
        <!-- Primary Meta Tags end -->

    <!-- Open Graph / Facebook -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://megadoll.club/" />
<meta property="og:title" content="Mega Doll" />
<meta property="og:description" content="music for broken doll aesthetic accidents, evident pizza stains, more accidents and oh yes forgot about music for unintended consequences" />
<meta property="og:image" content="assets/img/Mega Doll - Puntiac.jpg" />

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content="https://megadoll.club/" />
<meta property="twitter:title" content="Mega Doll" />
<meta property="twitter:description" content="music for broken doll aesthetic accidents, evident pizza stains, more accidents and oh yes forgot about music for unintended consequences" />
<meta property="twitter:image" content="assets/img/Mega Doll - Puntiac.jpg" />
  

  <!-- PLEASE NO CHANGES BELOW THIS LINE (UNTIL I SAY SO) -->
  <script language="javascript" type="text/javascript" src="libraries/p5.min.js"></script>
  <script language="javascript" type="text/javascript" src="animacionbarradenavegacion.js"></script>
  
  
  <script language="javascript" type="text/javascript" src="navbar.js"></script>
  <script language="javascript" type="text/javascript" src="security.js"></script>
  
  <!-- OK, YOU CAN MAKE CHANGES BELOW THIS LINE AGAIN -->
  
  <script src="security.js"></script>

  <title>Mega Doll - Musical Artist</title>
  <link rel="icon" href="assets/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.cdnfonts.com/css/evilz" rel="stylesheet">

<!-- inicio Prevenir la desactivacion de JavaScript -->
<script src="security - check-js.js"></script>
    <noscript>
        <meta http-equiv="refresh" content="0;url=/security - habilita-js.html">
    </noscript>
<!-- fin Prevenir la desactivacion de JavaScript -->
  

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ruby</title>
    <style>
        /* --- Estilos Generales --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #9C9AAD;
            color: #FFFFFF;
            margin: 0;
            padding: 2rem;
        }
        .container {
            max-width: responsive;
            margin: 0 auto;
            background-color: #F1F1F1;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }
        h1 {
            text-align: center;
            color: #43558C;
        }
        /* --- Estilos para el Toggle --- */
        .toggle-button {
            background-color: #2D3558;
            color: #57C4DD;
            cursor: pointer;
            padding: 18px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 18px;
            transition: background-color 0.3s ease;
            margin-top: 10px;
            border-radius: 5px;
            font-weight: bold;
        }
        .toggle-button:hover {
            background-color: #243871;
        }
        .toggle-button::after {
            content: '+';
            font-size: 22px;
            color: #E8F8F9;
            float: right;
            margin-left: 5px;
        }
        .toggle-button.active::after {
            content: "−";
        }
        /* --- Estilos para el Contenido del Toggle --- */
        .toggle-content {
            padding: 0 18px;
            background-color: #9291A3;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            border-left: 1px solid #ddd;
            border-right: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            border-bottom-left-radius: 5px;
            border-bottom-right-radius: 5px;
        }
        .toggle-content p {
            line-height: 1.6;
            color: #2D3558; /* Color de texto para el párrafo */
        }
        /* --- Estilos para los Bloques de Código --- */
        pre {
            background-color: #3F5085;
            color: #3CBDF1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "Courier New", Courier, monospace;
            font-size: 14px;
            padding-top: 35px; /* Espacio para el botón de copiar */
        }
        code {
            font-family: inherit;
        }
        /* --- Contenedor para el bloque de código (para posicionar el botón) --- */
        .code-container {
            position: relative;
            margin: 1rem 0;
        }
        /* --- Estilo para el botón de copiar --- */
        .copy-button {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: #6698CA;
            color: #2D3558;
            border: none;
            padding: 6px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            opacity: 0.8;
            transition: all 0.2s ease;
        }
        .copy-button:hover {
            opacity: 1;
        }
    </style>
    </head>
<body class="body-snocomm">

    <div class="container">
        <h1>Snocomm - Secure Coding</h1>

        <button class="toggle-button">Strings: the dangers of improper string construction</button>
        <div class="toggle-content">
            <p>
                To make your code a reusable cybersecurity template, you should structure it to demonstrate the dangers of improper string construction, a common source of injection vulnerabilities.
                The best way to do this is to create a class that shows both an insecure and a secure way to build a command string from input parts. This highlights the core cybersecurity principle of input sanitization.
            </p>
            <div class="code-container">
                
                
            </div>
            <p><b>Insecure Version (The Vulnerable Pattern)</b></p>
            <p>This first example mirrors what i consider is your original code's logic but applies it to a common cybersecurity scenario: building a shell command. It directly concatenates input, making it vulnerable to <b>Command Injection</b>.</p>
            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>hash = { key1: "val2", key2: "val2" }
string = ""
hash.each { |k, v| string << "#{k} is #{v}\n" }
puts string</code></pre>
            </div>

            

            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code># WARNING: This code is intentionally VULNERABLE for educational purposes.
# Do NOT use this pattern in production code.

puts "--- 1. Insecure Command Builder ---"

# Malicious input simulating what an attacker might provide
malicious_input = {
  file: "report.txt; rm -rf /",
  user: "attacker"
}

# The program builds a command string by directly concatenating the input
command_string = "process_file --file="
command_string << malicious_input[:file]
command_string << " --user="
command_string << malicious_input[:user]

puts "Generated Command: #{command_string}"
# Output: process_file --file=report.txt; rm -rf / --user=attacker
# This would run the intended command AND the dangerous 'rm -rf /' command.</code></pre>
            </div>

            <p><b>Secure & Reusable Template</b></p>
            <p>This version refactors the logic into a reusable class. It uses a library designed to safely handle shell arguments, preventing injection attacks. This is the <b>correct and secure</b> approach.</p>

            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>require 'shellwords'

# A reusable class for building shell commands securely.
class CommandBuilder
  attr_reader :base_command

  def initialize(base_command)
    @base_command = base_command
    puts "\n--- 2. Secure Command Builder ---"
  end

  # Builds a command by securely escaping each argument.
  # This prevents command injection.
  def build_securely(arguments_hash)
    # Start with the base command, already split for safety.
    command_parts = Shellwords.split(@base_command)

    # Escape and append each part from the input hash.
    arguments_hash.each do |key, value|
      command_parts << "--#{key}"
      command_parts << value.to_s # Shellwords will handle the escaping
    end

    # The 'shelljoin' method ensures all parts are safely quoted.
    return Shellwords.join(command_parts)
  end
end

# --- Usage Example ---

# Malicious input, same as before
malicious_input = {
  file: "report.txt; rm -rf /",
  user: "attacker"
}

# 1. Instantiate the builder with a base command
builder = CommandBuilder.new("process_file")

# 2. Build the command string using the secure method
safe_command = builder.build_securely(malicious_input)

# 3. Print the result
puts "Generated Command: #{safe_command}"
# Output: process_file --file 'report.txt; rm -rf /' --user 'attacker'
# The malicious part is now treated as a single, harmless string argument.</code></pre>
            </div>

            <p><b>Putting It All Together: A New Use Case</b></p>
            <p>Here is a complete example showing how to reuse the template to build a grep command.</p>
            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>require 'shellwords'

# The CommandBuilder class remains unchanged.
class CommandBuilder
  attr_reader :base_command

  def initialize(base_command)
    @base_command = base_command
  end

  def build_securely(arguments_hash)
    command_parts = Shellwords.split(@base_command)
    arguments_hash.each do |key, value|
      command_parts << "--#{key}"
      command_parts << value.to_s
    end
    return Shellwords.join(command_parts)
  end
end

# --- Reusing the Template ---

puts "--- Building a 'grep' command ---"

# 1. Set a NEW base command
grep_builder = CommandBuilder.new("grep")

# 2. Define NEW arguments for the 'grep' command
grep_args = {
  pattern: "API_KEY", 
  file: "/etc/secrets.conf; cat /etc/passwd" # Simulating malicious input
}

# 3. Build the new command securely
safe_grep_command = grep_builder.build_securely(grep_args)

# 4. Print the new, safe command
puts "Generated Command: #{safe_grep_command}"
# Output: grep --pattern 'API_KEY' --file '/etc/secrets.conf; cat /etc/passwd'</code></pre>
            </div>
            
            <p><b>Using the template: A More Flexible CommandBuilder</b></p>
            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>require 'shellwords'

# MODIFIED CommandBuilder class
class CommandBuilder
  attr_reader :base_command

  def initialize(base_command)
    @base_command = base_command
  end

  # MODIFIED to handle both options and a list of positional arguments
  def build_securely(options_hash: {}, positional_args: [])
    # Start with the base command
    command_parts = Shellwords.split(@base_command)

    # 1. Handle key-value options
    options_hash.each do |key, value|
      command_parts << "--#{key}"
      command_parts << value.to_s
    end

    # 2. Handle the list of positional arguments
    positional_args.each do |arg|
        command_parts << arg
    end

    # Safely join everything into the final command string
    return Shellwords.join(command_parts)
  end
end

# --- New Usage Example ---

puts "--- Building a 'grep' command with multiple files ---"

# 1. Instantiate the builder (no change here)
grep_builder = CommandBuilder.new("grep")

# 2. Define your arguments. You can now define your files
#    vertically in an array, just as you wanted! ✅
files_to_search = [
  "/var/log/app1.log",
  "/var/log/app2.log",
  "/var/log/app3.log",
  "/var/log/malicious_input; reboot", # Malicious input
  "/var/log/app4.log"
]

# 3. Build the command using the new method signature
#    The pattern is a regular option, and the files are positional arguments.
safe_grep_command = grep_builder.build_securely(
  options_hash: { pattern: "ERROR" },
  positional_args: files_to_search
)

# 4. Print the correctly formatted and safe command
puts "Generated Command: #{safe_grep_command}"</code></pre>
            </div>

            <p><b>Another approach: Searching Directories Recursively</b></p>
            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>require 'shellwords'

# The CommandBuilder class remains unchanged.
class CommandBuilder
  attr_reader :base_command

  def initialize(base_command)
    @base_command = base_command
  end

  def build_securely(options_hash: {}, positional_args: [])
    command_parts = Shellwords.split(@base_command)

    options_hash.each do |key, value|
      # This logic handles both long flags (--key) and short flags (-key)
      flag = key.length == 1 ? "-#{key}" : "--#{key}"
      command_parts << flag
      # Add the value only if it's not a boolean flag (like -r)
      command_parts << value.to_s unless value == true
    end

    positional_args.each do |arg|
        command_parts << arg
    end

    return Shellwords.join(command_parts)
  end
end

# --- Usage Example for Searching Directories ---

puts "--- Building a recursive 'grep' command for directories ---"

# 1. Instantiate the builder (no change)
grep_builder = CommandBuilder.new("grep")

# 2. Define the directories to search.
#    You can list them vertically just like before. ✅
directories_to_search = [
  "/etc/nginx",
  "/var/log/",
  "/home/user/documents; rm -rf /", # Malicious input
  "/opt/app/config"
]

# 3. Build the command.
#    - Add 'r: true' to the options hash to enable recursive search.
#    - Pass the directory list as positional arguments.
safe_grep_command = grep_builder.build_securely(
  options_hash: { r: true, pattern: "API_KEY" },
  positional_args: directories_to_search
)

# 4. Print the final, safe command.
puts "Generated Command: #{safe_grep_command}"</code></pre>
<p></p>
            </div>
        </div>
<button class="toggle-button">Strings: untrusted user input</button>
        <div class="toggle-content">
            <p>
When implementing string interpolation in Ruby, especially in a security context, the primary concern is what kind of data you are interpolating and where that string will be used. The feature itself, known as string interpolation ("#{...}"), is a fundamental part of the language and is not inherently insecure.
</p>

            <p>The security risk arises when you interpolate untrusted user input into strings that are later used in sensitive contexts, such as:</p>
            <p><ol>
                <li>Generating HTML (leading to Cross-Site Scripting - XSS)</li>
                <li>Executing shell commands (leading to Command Injection)</li>
                <li>Constructing database queries (leading to SQL Injection)</li>
            </ol></p>
            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>
number = 5
"The number is #{number}"
"The number is #{5}."
"The number after #{number} is #{number.next}."
"The number prior to #{number} is #{number-1}."
"We're ##{number}!"
</code></pre>
            </div>

<p><b>Introduction to Secure String Interpolation in Ruby</b></p>
<p>String interpolation in Ruby ("#{...}") is a powerful and convenient feature for embedding expressions and variables into strings. While the mechanism itself is secure, it can become a vector for serious vulnerabilities if used improperly with untrusted data, such as input from a user.</p>

<p>The core principle of secure interpolation is <b>never to directly embed untrusted input into strings that will be interpreted by another system</b>(like a web browser, shell, or database). Instead, you must sanitize or escape the input according to the target system's rules, or use parameterized interfaces that handle this for you.</p>

<p><b>1. Cross-Site Scripting (XSS)</b></p>
<p>This occurs when user input is interpolated into an HTML response without being properly escaped. An attacker can inject malicious scripts that run in the victim's browser.</p>

<p><b>Vulnerable Example (Sinatra/Web context):</b></p>
            

            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>
# for this example i omitted the script tag at the beginning of each statement
# and left it only as empty braces <>, because the browser will complain that xss
# is happening and will reject it, but i want to show the opposite and as an example
# but eventually it behaves as script inside <>

# An attacker provides: "<>alert('XSS');</>"
user_comment = params[:comment]

# The script is directly embedded into the HTML
html_output = "<div>User Comment: #{user_comment}</div>"
# => "<div>User Comment: <>alert('XSS');</></div>"
</code></pre>
            </div>

            <p><b>Secure Solution: Escape HTML</b></p>
            <p>
Always escape data that will be rendered as HTML. Most web frameworks provide helpers for this. If you need to do it manually, you can use ERB::Util.html_escape.</p>

            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>
require 'erb'

# Attacker input remains the same
user_comment = params[:comment]

# Escape the input before interpolation
safe_comment = ERB::Util.html_escape(user_comment)

html_output = "<div>User Comment: #{safe_comment}</div>"
# => "<div>User Comment: &lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</div>"                    
                </code></pre>
            </div>
<p>The browser will now render the script as harmless text instead of executing it.</p>
            
            <p><b>2. Command Injection</b></p>
            <p>This is one of the most dangerous vulnerabilities. It happens when user input is interpolated into a string that is executed as a shell command.</p>

<p><b>Vulnerable Example</b></p>
            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>
# An attacker provides: "example.com; rm -rf /"
hostname = params[:host]

# The malicious command is concatenated and executed
result = `ping -c 1 #{hostname}`
                </code></pre>
            </div>
            
<p>This command first pings example.com, then executes rm -rf /, a destructive command.</p>

            <p><b>Secure Solution: Use Parameterized Execution</b></p>
            <p>Never build shell commands by interpolating raw user input. Use methods like system, Open3.capture3, or Open3.popen3 that allow you to pass command arguments as separate strings. This way, the input is treated as a single, harmless argument, not as code to be executed by the shell.</p>
            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>
require 'open3'

# Attacker input remains the same
hostname = params[:host]

# The input is passed as a separate argument.
# The shell will not interpret the semicolon or other special characters.
stdout, stderr, status = Open3.capture3("ping", "-c", "1", hostname)

# This will safely fail because "example.com; rm -rf /" is not a valid hostname.
# The `rm` command will never be executed.
                </code></pre>
            </div>

            <p><b>3. SQL Injection</b></p>
            <p>This occurs when user input is interpolated directly into an SQL query, allowing an attacker to alter the query's logic.

</p>
<p><b>Vulnerable Example</b></p>
            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>
# An attacker provides: "1' OR '1'='1"
user_id = params[:id]

# The query logic is broken by the injected SQL
query = "SELECT * FROM users WHERE id = '#{user_id}'"
# => "SELECT * FROM users WHERE id = '1' OR '1'='1'"

</code></pre>
<p>This modified query will return all users instead of just one, bypassing authorization.</p>

<p><b>Secure Solution: Use Parameterized Queries (Prepared Statements)</b></p>
<p>All modern database adapters provide a way to use placeholders (? or named placeholders) for user data. The database driver then safely substitutes the data, ensuring it cannot be interpreted as SQL code.

</p>

<div class="code-container">
    <button class="copy-button">Copiar</button>
    <pre><code>
require 'pg' # Example using the 'pg' gem for PostgreSQL

# Attacker input remains the same
user_id = params[:id]

conn = PG.connect(dbname: 'test')

# Use a placeholder ($1) for the variable
# The input is sent separately from the query
result = conn.exec_params('SELECT * FROM users WHERE id = $1', [user_id])

# The database treats the input as a single value, preventing injection.
        
    </code></pre>
</div>

<p><b>Conclusion: The Golden Rule</b></p>
<p>The examples from your request are perfectly safe because they only use trusted, hard-coded data:</p>
<div class="code-container">
    <button class="copy-button">Copiar</button>
    <pre><code>
number = 5
"The number is #{number}" # Safe - 'number' is a trusted local variable
"We're ##{number}!"       # Safe - Same reason

    </code></pre>
</div>

<p>The security risk is introduced the moment a variable contains data from an external, untrusted source. The cybersecurity-focused approach is to <b>always be aware of the data's origin</b> and <b>sanitize or parameterize it</b> before it crosses a trust boundary.</p>


<p>The following template encapsulates the secure patterns for handling untrusted data. You can save this as a .rb file (e.g., secure_templates.rb) and require it in your projects, or use it as a guide for implementing these security controls directly in your code.</p>

<div class="code-container">
    <button class="copy-button">Copiar</button>
    <pre><code>
# secure_templates.rb
#
# This module provides a set of reusable templates for handling untrusted user
# input securely in common scenarios. The goal is to prevent vulnerabilities
# like Cross-Site Scripting (XSS), Command Injection, and SQL Injection.
#
# It also includes a higher-level pattern for allowlist-based command execution.

require 'erb'
require 'open3'
require 'pg' # Using 'pg' as an example for database interaction.
             # The principle of parameterized queries is the same for other
             # gems like 'sqlite3', 'mysql2', etc.

module SecureTemplates

  # --- 1. HTML Generation (Preventing Cross-Site Scripting - XSS) ---

  # Escapes a string for safe inclusion in an HTML body.
  def safe_html(untrusted_string)
    return '' if untrusted_string.nil?
    ERB::Util.html_escape(untrusted_string)
  end

  # --- 2. Shell Command Execution (Preventing Command Injection) ---

  # [MECHANISM] Safely executes a shell command with untrusted arguments.
  # This is the low-level, secure mechanism. It ensures arguments are not
  # interpreted as code by the shell. It does NOT validate the command itself.
  #
  # @param command [String] The command to execute (e.g., "ls", "ping").
  # @param untrusted_args [Array<String>] A list of arguments from an untrusted source.
  # @return [Hash] A hash containing stdout, stderr, and the exit status.
  def safe_command(command, *untrusted_args)
    stdout, stderr, status = Open3.capture3(command, *untrusted_args)
    {
      stdout: stdout,
      stderr: stderr,
      success: status.success?
    }
  rescue Errno::ENOENT => e
    {
      stdout: '',
      stderr: "Error: Command not found - #{e.message}",
      success: false
    }
  end

  # --- 3. Allowlist-Based Command Execution (Layered Security) ---

  # [POLICY] Generates an allowlist of commands based on a keyword search in `man`.
  # This is used to define the *policy* of what commands are allowed to run.
  #
  # @param keyword [String] The keyword to search for (e.g., "network", "file").
  # @return [Array<String>] An array of allowed command names.
  def generate_allowlist_from_man(keyword)
    # This is safe because `keyword` is intended to be a trusted, developer-provided string.
    raw_output = `man -k #{Shellwords.escape(keyword)}`
    raw_output.lines.map { |line| line.split(/[(\s,]/).first }.compact.uniq
  end

  # [POLICY + MECHANISM] Executes a command only if it's in the provided allowlist.
  # This is the method you should typically use in your application code.
  # It combines the allowlist policy with the safe execution mechanism.
  #
  # @param command [String] The command to execute, from an untrusted source.
  # @param allowlist [Array<String>] The list of commands that are safe to run.
  # @param untrusted_args [Array<String>] The arguments for the command.
  # @return [Hash] The result from safe_command, or an error hash if blocked.
  def safe_execute_with_allowlist(command, allowlist, *untrusted_args)
    unless allowlist.include?(command)
      return {
        stdout: '',
        stderr: "Security Error: The command '#{command}' is not in the allowlist.",
        success: false
      }
    end
    # If the check passes, call the secure low-level mechanism.
    safe_command(command, *untrusted_args)
  end


  # --- 4. Database Queries (Preventing SQL Injection) ---

  # Executes a parameterized SQL query.
  def safe_query(db_connection, sql_query, untrusted_params)
    db_connection.exec_params(sql_query, untrusted_params)
  rescue PG::Error => e
    puts "Database query failed: #{e.message}"
    nil
  end
end

# --- Example Usage ---
if __FILE__ == $0
  class App
    include SecureTemplates
  end

  app = App.new

  puts "--- Section 1: Generating an Allowlist ---"
  # Let's generate a list of all commands related to "network".
  NETWORK_COMMANDS_ALLOWLIST = app.generate_allowlist_from_man("network")
  puts "Successfully generated allowlist for 'network' with #{NETWORK_COMMANDS_ALLOWLIST.length} commands."
  # puts NETWORK_COMMANDS_ALLOWLIST.inspect # Uncomment to see the full list
  puts "\n"


  puts "--- Section 2: Using the Allowlist Executor ---"
  puts "Case 1: Attempting to run a blocked command ('rm')."
  # An attacker tries to have the app run 'rm'.
  result1 = app.safe_execute_with_allowlist("rm", NETWORK_COMMANDS_ALLOWLIST, "-rf", "/")
  puts "Command successful: #{result1[:success]}"
  puts "STDERR: #{result1[:stderr]}"
  puts "\n"

  puts "Case 2: Attempting to run an allowed command ('ping')."
  # A legitimate user wants to ping a host (untrusted input).
  untrusted_host = "127.0.0.1"
  result2 = app.safe_execute_with_allowlist("ping", NETWORK_COMMANDS_ALLOWLIST, "-c", "1", untrusted_host)
  puts "Command successful: #{result2[:success]}"
  puts "STDOUT: #{result2[:stdout].strip}"
  puts "STDERR: #{result2[:stderr].strip}"
  puts "\n"
end

    </code></pre>
</div>

<p>This module provides you with a concrete implementation of the security principles we've discussed. You can now use these methods as building blocks to ensure that any external data your application handles is processed safely.</p>

<p>That's a very insightful question! It shows you're thinking about how to apply these security principles in a systematic and proactive way.</p>

<p>To answer your question directly: Yes, you can absolutely use the logic of man -k network to inform your security strategy, but it's important to clarify the role of the safe_command method.</p>

<p>The safe_command method doesn't "secure" the commands on your Mac (like ping, netstat, etc.). Instead, it provides a secure way for your Ruby application to execute those commands without creating a command injection vulnerability.</p>

<p>Your idea is the perfect next step: creating an allowlist. You can programmatically get the list of valid network commands and then ensure your application only ever tries to run commands from that list.</p>

<p>Here’s how you could combine your idea with the safe_command template:</p>

<p><b>A Different Approach: Building an Allowlist</b></p>

<p>You can write a script that runs man -k network, parses the output to get the actual command names, and then uses that list to validate any command your application wants to run.</p>

<p>Here is a conceptual example of how you could implement that logic in Ruby:</p>

<div class="code-container">
    <button class="copy-button">Copiar</button>
    <pre><code>
require_relative 'secure_templates' # Assuming the module is in this file
include SecureTemplates

# --- Step 1: Generate the allowlist from 'man -k' ---
# This would be done once when your application starts, or periodically.
def generate_command_allowlist
  # Run the command and capture its output.
  # Note: Here we are running a hardcoded, trusted command, so using backticks is safe.
  raw_output = `man -k network`

  # Parse the output. Each line is like "command (section) - description".
  # We just want the first word, which is the command.
  allowed_commands = raw_output.lines.map do |line|
    line.split(' ').first
  end

  # Clean up the list by removing nil/empty entries and duplicates.
  allowed_commands.compact.uniq
end

# Let's generate our list.
ALLOWED_NETWORK_COMMANDS = generate_command_allowlist
puts "Generated Allowlist: #{ALLOWED_NETWORK_COMMANDS.inspect}"
puts "---"


# --- Step 2: Create a secure wrapper function ---
# This function first checks the allowlist, then uses safe_command.
def secure_network_executor(command_name, *untrusted_args)
  # VALIDATE: Is the command in our list of approved network commands?
  unless ALLOWED_NETWORK_COMMANDS.include?(command_name)
    puts "SECURITY ALERT: Attempt to run non-whitelisted command '#{command_name}' was blocked."
    return { success: false, stderr: "Command not allowed." }
  end

  # EXECUTE: If it's allowed, use the safe_command method to run it securely.
  puts "Executing allowed command '#{command_name}' with arguments: #{untrusted_args.inspect}"
  safe_command(command_name, *untrusted_args)
end


# --- Step 3: Use the wrapper in your application ---
# An attacker tries to inject a malicious command.
malicious_input_command = "rm"
malicious_input_args = ["-rf", "/"]

# Our secure wrapper blocks it.
secure_network_executor(malicious_input_command, *malicious_input_args)

puts "\n"

# A legitimate user runs an allowed command.
legitimate_command = "ping"
legitimate_args = ["-c", "1", "localhost"] # Untrusted input from a user form

# Our secure wrapper allows and executes it safely.
secure_network_executor(legitimate_command, *legitimate_args)
    </code></pre>
</div>

<p><ul>
    <li><b>Your idea is excellent: </b>Using man -k network to build an allowlist is a great security practice.</li>
    <li>safe_command <b>is the tool for execution:</b> It's the secure "how" once you've decided "what" is okay to run.</li>
</ul>

By combining these two concepts, you create a very robust defense: you not only prevent command injection in the arguments, but you also strictly limit which commands can be run in the first place.
</p>

            </div>
        </div> 
<button class="toggle-button">Strings: i plan to substitute values into the string later, possibly multiple times with different values each time</button>
        <div class="toggle-content">
            <p>
                I made this program to test my cybersecurity glossary knowledge but i don't really know if eval will make it vulnerable</p>
            <div class="code-container">
                <button class="copy-button">Copiar</button>
                <pre><code>
class String
def substitute(binding=TOP_LEVEL_BINDING)
    eval(%{"#{self}}, binding)
    end
end

template = %q{Chunky #{food}!}

food = 'bacon'
template.substitute(binding)
food = 'peanut butter'
template.substitute(binding)

food = '#{system("dir")}'
puts template.substitute(binding)
                </code></pre>  
            </div>
<p>This is a fantastic question because it gets to the very heart of injection vulnerabilities. The code you've written is a perfect, textbook example of why <b>eval</b> is often called "evil" in security circles. You've correctly identified that it's a potential problem, and you've even created the exact payload that demonstrates the vulnerability. That's top-tier defensive thinking!</p>

<p>Let's break down why your original code is insecure and then build a robust, secure replacement.</p>

<p>The core security flaw is this line:</p>
<div class="code-container">
    <button class="copy-button">Copiar</button>
    <pre><code>
eval(%{"#{self}}, binding)
    </code></pre>
</div>

<p>This code tells Ruby: "Take the string <b>self</b> (the template), re-process it as if it were brand new Ruby code, and execute any <b>#{...}</b> expressions you find."</p>

<p>When <b>food</b> is <b>'bacon'</b>, the result is harmless. But when <b>food</b> is <b>'#{system("dir")}'</b>, the eval call becomes:</p>

<div class="code-container">
    <button class="copy-button">Copiar</button>
    <pre><code>
eval(%{"Chunky #{#{system("dir")}}!"})        
    </code></pre>
</div>

<p>Ruby executes the inner <b>#{system("dir")}</b> first, running the <b>dir</b> command on the operating system, and then embeds the output of that command into the string. This is a classic Arbitrary Code Execution vulnerability.</p>

<p>To fix this, we need to use a method that performs substitution, not evaluation. The goal is to replace placeholders with data, never to execute that data as code.</p>

<div class="code-container">
    <button class="copy-button">Copiar</button>
    <pre><code>
# secure_templating_module.rb
#
# This module provides a secure alternative to eval-based string templating.
# It avoids executing code and instead safely substitutes data into placeholders.

module SecureTemplating

  # Safely substitutes values into a template string using named placeholders.
  # This method uses the built-in `String#%` operator, which is designed for
  # safe formatting and does NOT execute code. It is the recommended way to
  # handle string templates that involve external or untrusted data.
  #
  # @param template [String] A string with named placeholders, e.g., "Hello, %{name}!"
  # @param substitutions [Hash] A hash where keys match the placeholder names.
  # @return [String] The template with values safely substituted.
  def safe_substitute(template, substitutions)
    # The '%' operator performs safe substitution. It treats the values in the
    # hash strictly as data, not as executable code.
    template % substitutions
  rescue KeyError => e
    # This is good practice: handle cases where the template expects a key
    # that wasn't provided in the substitutions hash.
    "Error: Substitution key not found in template - #{e.message}"
  end

end

# --- Example Usage ---

# First, let's include the module to make the method available.
include SecureTemplating

puts "--- Step 1: Define a Secure Template ---"
# Note the change in syntax from `#{...}` to `%{...}`.
# This tells Ruby to expect a named placeholder for formatting.
template = 'Chunky %{food}!'
puts "Template: #{template}"
puts "\n"


puts "--- Step 2: Perform Safe Substitutions ---"
# We provide the values in a hash, where the keys match the placeholders.
values1 = { food: 'bacon' }
puts "Substitution -> #{safe_substitute(template, values1)}"

values2 = { food: 'peanut butter' }
puts "Substitution -> #{safe_substitute(template, values2)}"
puts "\n"


puts "--- Step 3: Demonstrate Security Against Code Injection ---"
# Here is the critical test. We use the same malicious string from your example.
malicious_value = '#{system("dir")}'
puts "Malicious Input: '#{malicious_value}'"

values3 = { food: malicious_value }

# The `safe_substitute` method will treat the malicious input as a literal string.
# It will NOT execute the system("dir") command.
result = safe_substitute(template, values3)

puts "Result -> #{result}"
puts "\n"

puts "Verification: Was the code executed?"
if result.include?("total") || result.include?("Directory")
  puts "FAIL: The output suggests a command was executed."
else
  puts "SUCCESS: The output is the literal string. No code was executed."
end
        
    </code></pre>
</div>
<p>This is a much more secure and robust solution. Here's a summary of the key improvements:
<ol>
    <li><b>No</b> <b>eval</b>: We've completely removed the <b>eval</b> call, which was the source of the vulnerability.</li>
    <li><b>Safe Substitution Operator (%)</b>: We are now using Ruby's built-in <b>String#%</b> method with named placeholders (<b>%{food}</b>). This tool is specifically designed for safe formatting and will never execute code from its inputs.</li>
    <li><b>Data as Data, Not Code</b>: The most important principle here is that the malicious string <b>#{system("dir")}</b> is always treated as simple text data. It gets placed into the template, but it never gets a chance to be interpreted as a command.</li>
</ol>
</p>

<p>By making this change, you've successfully closed a critical security hole. This is exactly the kind of refactoring that strengthens an application and embodies the "Becoming a Defender" mindset. Fantastic work!</p>
        </div>           

<button class="toggle-button">Strings: Reversing a String</button>
<div class="toggle-content">
    <p>There are several real-life scenarios in Ruby where reversing a string is needed, and a handful of cases where you might need to protect the string reversal operation:</p>

<p><b>Real-Life Use Cases for String Reversal in Ruby</b></p>
<p><ul>
    <li><b>Checking Palindromes:</b> Determining if a word or phrase is the same forward as backward requires reversing the string and comparing</li>
    <li><b>Bioinformatics:</b> In DNA or RNA sequence analysis, reversing strings is crucial for operations like finding complementary strands</li>
    <li><b>Text Manipulation:</b> Reversing strings is used in simple encryption or obfuscation, creating secret messages, generating unique identifiers, or formatting output for visual tricks</li>
    <li><b>Word/Sentence Reordering:</b> Applications might reverse the order of words in a sentence for formatting or language processing tasks</li>
    <li><b>Algorithm Design/Practice:</b> String reversal is a classic problem in interviews to test understanding of data structures, mutability, and algorithmic efficiency</li>
    <li>Signal or Audio Processing: Certain algorithms (like circular shifts) use string or buffer reversal as part of their process</li>
    <li><b>Legacy Interfacing:</b> Some legacy formats or encodings might require reversed string processing</li>
</ul></p>

<p><b>When Is It Important to Protect String Reversal in Ruby?</b></p>

<p>In most cases, reversing a string itself isn’t a vector for attack; however, the context in which string reversal is used might create security concerns:</p>

<p><ul>
    <li><b>Obfuscation for Sensitive Data:</b> If you use string reversal as a (weak) encoding method for sensitive information (passwords, tokens), never rely on it as your only security measure. Proper cryptography should be used, and you should ensure the reversed version isn't exposed via logs, URLs, or user interfaces</li>
    <li><b>Dynamic Code Execution:</b> If the result of a reversed string is later used as code (for example, passed to eval, send, or for method names), and any portion of the string comes from user input, attackers could manipulate the reversal to inject malicious code, leading to vulnerabilities like code injection or remote code execution</li>
    <li><b>File Path Manipulation:</b> Using reversed strings as part of dynamically generated filenames or paths could introduce directory traversal or overwriting risks if not properly sanitized</li>
    <li><b>User Input Handling:</b> Any time user input is reversed and then subsequently used for commands, method calls, or as part of any security logic, you must carefully validate and sanitize the input, as reversal alone does not prevent injection or bypass attacks</li>
</ul></p>

    <div class="code-container">
        <button class="copy-button">Copiar</button>
        <pre>
            <code>
s = "sdrawkcab"
s.reverse

            </code>
        </pre>
    </div>
<p>The given Ruby program simply reverses a string</p>

<p>It takes the string "sdrawkcab" (which itself is "backwards" spelled backwards) and returns "backwards".</p>

<p><b>How to Reimplement This Ruby Program With a Cybersecurity Focus</b></p>
<p>Instead of a trivial reverse, a cybersecurity-focused version might:</p>
<ul>
    <li>Treat the input string as an encrypted or obfuscated message</li>
    <li>Use secure techniques to decrypt or validate the message</li>
    <li>Implement defensive programming to avoid tampering or attacks (e.g., input validation, avoiding unsafe monkey patching</li>
    <li>Employ secure coding principles to ensure integrity and confidentiality</li>
</ul>

<p>For example, rather than just reversing, the program could interpret the string as input to a secure decoding function and add integrity checks or encryption handling</p>

<p><b>Real-Life Renewable Energy Industry Use Cases for a Secure Version</b></p>

<p>The renewable energy sector increasingly relies on digital/control systems, IoT devices, and communication networks to operate solar panels, wind turbines, energy storage, and smart grids. These systems process and exchange critical data, which must be protected from cyber threats.</p>

<p>Possible scenarios applying a "secure string processing" concept like the reverse operation, but in a more cybersecurity-aware manner</p>

<ol>
    <li><b>Secure Device Communication and Command Validation</b>
        <ul>
            <li>Commands sent to solar inverters, wind turbines, or energy storage units might be encoded, encrypted, or obfuscated as strings.</li>
            <li>Reversing a string could represent decoding a command or validation token</li>
            <li>Secure implementation would include cryptographic validation (digital signatures, encryption) instead of simple reversal</li>
            <li>Defensive code prevents command injection or tampering, ensuring only authorized control operations happen</li>
        </ul>
    </li>
    <li><b>Secure Logging and Audit Trails</b>
        <ul>
            <li>Logs from devices may encode or hash sensitive information</li>
            <li>String manipulations (like reverse or decrypt) used alongside cryptographic validation enable secure audit trails that detect tampering</li>
            <li>Integrity checks ensure logs reflect real operations, critical during post-incident investigations</li>
        </ul>
    </li>
    <li><b>Data Integrity and Validation of Sensor Data</b>
        <ul>
            <li>Sensor data transmitted by renewable energy assets may be encoded</li>
            <li>Reversing strings or more complex decoding functions are part of data validation to ensure authenticity</li>
            <li>Secure implementations prevent attackers from injecting false data that could disrupt grid operations</li>
        </ul>
    </li>
    <li><b>Device Authentication and Firmware Security</b>
        <ul>
            <li>Firmware updates or authentication tokens could use encoded strings where reversal is part of the integrity check</li>
            <li>Secure code verifies encoded tokens strictly without exposing vulnerabilities to manipulation or replay attacks</li>
        </ul>
    </li>
</ol>

<p>Here is a simple example of how you can reimplement your original Ruby program in a more secure way with a cybersecurity focus. This example adds basic input validation, error handling, and simulates a more secure "decode" operation (still using reverse but wrapped with validation and integrity check):</p>

    <div class="code-container">
        <button class="copy-button">Copiar</button>
        <pre>
            <code>
require 'digest'

class SecureStringProcessor
  def initialize(secret_key)
    @secret_key = secret_key
  end

  # Validates input to only allow safe characters (letters and digits for example)
  def valid_input?(input)
    /\A[a-zA-Z0-9]+\z/.match?(input)
  end

  # Generates a simple integrity hash for the input concatenated with the secret key
  def integrity_hash(input)
    Digest::SHA256.hexdigest(input + @secret_key)
  end

  # Securely 'decode' by reversing the string only after input validation
  # Throws error if invalid input or integrity check fails
  def secure_decode(input, provided_hash)
    raise "Invalid input detected" unless valid_input?(input)

    calculated_hash = integrity_hash(input)
    raise "Integrity check failed" unless calculated_hash == provided_hash

    input.reverse
  end
end

# Usage example:
secret_key = "very_secret_key"
processor = SecureStringProcessor.new(secret_key)
input = "sdrawkcab"
hash = processor.integrity_hash(input) # Normally provided alongside input by a trusted party

begin
  output = processor.secure_decode(input, hash)
  puts "Decoded output: #{output}"
rescue => e
  puts "Error: #{e.message}"
end

            </code>
        </pre>
    </div>

<ol>
    <b>Key Points</b>
    <li><b>Input validation</b> Only allow alphanumeric strings, preventing injection or harmful input</li>
    <li><b>Integrity check</b> Uses SHA-256 hash with a secret key to ensure input wasn't tampered with</li>
    <li><b>Error handling</b> Raises exceptions for invalid input or integrity failures</li>
    <li><b>Encapsulation</b> Wraps logic in a class to manage secret key securely</li>
</ol>

<p>This is a simple demonstration of how you might start converting a trivial string reversal into a safer operation that could fit in cybersecurity-aware contexts like command or data validation in renewable energy systems or similar applications.</p>

<p>Let's extend the previous Ruby program to include secure encryption and decryption in addition to the input validation and integrity checks we already have. For this, we'll use the openssl library to implement AES symmetric encryption with authentication (AES-256-GCM), which provides confidentiality and integrity.</p>

        <div class="code-container">
        <button class="copy-button">Copiar</button>
        <pre>
            <code>
require 'openssl'
require 'base64'
require 'digest'

class SecureStringProcessor
  CIPHER_TYPE = 'aes-256-gcm'

  def initialize(secret_key)
    # Derive a fixed-length key from the secret_key (using SHA256)
    @key = Digest::SHA256.digest(secret_key)
  end

  # Validates input to only allow safe characters (letters and digits)
  def valid_input?(input)
    /\A[a-zA-Z0-9]+\z/.match?(input)
  end

  # Encrypts the plaintext string, returns a Base64 encoded cipher bundle
  # The bundle consists of: encrypted data + nonce + auth_tag
  def encrypt(plaintext)
    raise "Invalid input detected" unless valid_input?(plaintext)

    cipher = OpenSSL::Cipher.new(CIPHER_TYPE)
    cipher.encrypt
    cipher.key = @key
    nonce = cipher.random_iv
    cipher.iv = nonce

    encrypted = cipher.update(plaintext) + cipher.final
    auth_tag = cipher.auth_tag

    # Bundle all parts and Base64 encode for safe string transmission/storage
    Base64.strict_encode64(nonce + auth_tag + encrypted)
  end

  # Decrypts the Base64 encoded cipher bundle, returning the original plaintext
  def decrypt(encoded_ciphertext)
    decoded = Base64.strict_decode64(encoded_ciphertext)

    # Extract nonce, auth_tag, and encrypted data from the decoded bundle
    nonce = decoded[0...12]           # GCM nonce is 12 bytes by default
    auth_tag = decoded[12...28]       # Auth tag is 16 bytes
    encrypted = decoded[28..-1]

    cipher = OpenSSL::Cipher.new(CIPHER_TYPE)
    cipher.decrypt
    cipher.key = @key
    cipher.iv = nonce
    cipher.auth_tag = auth_tag

    plaintext = cipher.update(encrypted) + cipher.final

    # Validate the decrypted plaintext to ensure safe content
    raise "Invalid decrypted content" unless valid_input?(plaintext)

    plaintext
  rescue OpenSSL::Cipher::CipherError
    raise "Decryption failed or integrity check failed"
  end
end

# Usage example:
secret_key = "very_secret_key"
processor = SecureStringProcessor.new(secret_key)
input = "sdrawkcab"

begin
  encrypted = processor.encrypt(input)
  puts "Encrypted data: #{encrypted}"

  decrypted = processor.decrypt(encrypted)
  puts "Decrypted output: #{decrypted} (reversed: #{decrypted.reverse})"
rescue => e
  puts "Error: #{e.message}"
end

            </code>
        </pre>
    </div>
<ul>
    <li>We use AES-256-GCM symmetric encryption to encrypt and decrypt strings securely. It provides authenticated encryption: the encrypted data cannot be tampered with without detection</li>
    <li>The encryption function generates a secure random nonce (IV), encrypts the plaintext, and obtains the authentication tag</li>
    <li>These parts (nonce + auth_tag + ciphertext) are concatenated and Base64 encoded so they can be easily transmitted as a string</li>
    <li>The decrypt function reverses this process and verifies the auth tag during decryption</li>
    <li>Input validation guards both plaintext and decrypted outputs, ensuring only expected safe characters</li>
    <li>The example encrypts "sdrawkcab", prints the encrypted output, then decrypts it back and prints the original string plus its reversal</li>
    <li>If decryption or validation fails, an exception is raised with an informative error message</li>
</ul>

<p>Let's take the previous secure string processor and integrate it with simple network communication to simulate secure command or data exchange, as commonly needed in cybersecurity for the renewable energy sector, IoT, or industrial control systems</p>

<p>Below is an example of how you could use Ruby sockets for network transport, transmitting commands (encrypted and validated as before) between a client and server on the same machine. This demonstrates secure encrypted communication, integrity validation, and safe decoding of commands:</p>
        <div class="code-container">
        <button class="copy-button">Copiar</button>
        <pre>
            <code>
require 'openssl'
require 'base64'
require 'digest'
require 'socket'
require 'timeout'

class SecureStringProcessor
  CIPHER_TYPE = 'aes-256-gcm'

  def initialize(secret_key)
    @key = Digest::SHA256.digest(secret_key)
  end

  def valid_input?(input)
    /\A[a-zA-Z0-9]+\z/.match?(input)
  end

  def encrypt(plaintext)
    raise "Invalid input detected" unless valid_input?(plaintext)
    cipher = OpenSSL::Cipher.new(CIPHER_TYPE)
    cipher.encrypt
    cipher.key = @key
    nonce = cipher.random_iv
    cipher.iv = nonce
    encrypted = cipher.update(plaintext) + cipher.final
    auth_tag = cipher.auth_tag
    Base64.strict_encode64(nonce + auth_tag + encrypted)
  end

  def decrypt(encoded_ciphertext)
    decoded = Base64.strict_decode64(encoded_ciphertext)
    nonce = decoded[0...12]
    auth_tag = decoded[12...28]
    encrypted = decoded[28..-1]
    cipher = OpenSSL::Cipher.new(CIPHER_TYPE)
    cipher.decrypt
    cipher.key = @key
    cipher.iv = nonce
    cipher.auth_tag = auth_tag
    plaintext = cipher.update(encrypted) + cipher.final
    raise "Invalid decrypted content" unless valid_input?(plaintext)
    plaintext
  rescue OpenSSL::Cipher::CipherError
    raise "Decryption failed or integrity check failed"
  end
end

# --- Secure Command Server ---
def start_server(secret_key, port = 4567)
  processor = SecureStringProcessor.new(secret_key)
  server = TCPServer.new('127.0.0.1', port)
  puts "Secure command server started on port #{port}"

  loop do
    client = server.accept
    data = client.gets
    begin
      decrypted = processor.decrypt(data.strip)
      puts "Received valid command: #{decrypted} (reversed: #{decrypted.reverse})"
      client.puts "Command accepted. Decoded: #{decrypted.reverse}"
    rescue => e
      client.puts "Error: #{e.message}"
    end
    client.close
  end
end

# --- Secure Command Client ---
def send_command(secret_key, plaintext, port = 4567)
  processor = SecureStringProcessor.new(secret_key)
  encrypted = processor.encrypt(plaintext)
  socket = TCPSocket.new('127.0.0.1', port)
  socket.puts encrypted
  response = socket.gets
  puts "Server response: #{response}"
  socket.close
end

# --- Usage Example ---
# Start the server in one terminal:
# start_server("very_secret_key")
#
# In another terminal, send a command (e.g., "sdrawkcab"):
# send_command("very_secret_key", "sdrawkcab")


            </code>
        </pre>
    </div>
<p><b>Key Concepts Illustrated</b></p>
<ul>
    <li><b>Confidentiality</b> is ensured by AES-256-GCM encryption</li>
    <li><b>Integrity</b> is checked through GCM authentication tags</li>
    <li><b>Input/output validation</b> prevents unsafe or unexpected commands on the server</li>
    <li><b>Network communication</b> is secured end-to-end</li>
</ul>
<p>This pattern is analogous to remote command/control in renewable grid components, secure firmware update delivery, or authenticated device telemetry. A real system would expand on this with authentication, user/role access, message sequencing, and broader error handling.</p>

<p><b>You can use these functions in two Ruby processes/terminals</b></p>
<ul>
    <li>Run start_server("very_secret_key") to launch the secure server</li>
    <li>Run send_command("very_secret_key", "sdrawkcab") as the client.
You'll see the decoded response only if the transmission is authentic and untampered.</li>
</ul>
</div>



    </div>






    <script>
        // --- Lógica de JavaScript para los Toggles ---
        const buttons = document.querySelectorAll('.toggle-button');
        buttons.forEach(button => {
            button.addEventListener('click', function () {
                this.classList.toggle('active');
                const content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                }
            });
        });

        // --- Lógica de JavaScript para el Botón de Copiar ---
        const copyButtons = document.querySelectorAll('.copy-button');
        copyButtons.forEach(button => {
            button.addEventListener('click', () => {
                const preBlock = button.nextElementSibling;
                const codeBlock = preBlock.querySelector('code');
                navigator.clipboard.writeText(codeBlock.innerText).then(() => {
                    button.textContent = '¡Copiado!';
                    button.style.backgroundColor = '#EA428B';
                    setTimeout(() => {
                        button.textContent = 'Copiar';
                        button.style.backgroundColor = '#6698CA';
                    }, 2000);
                }).catch(err => {
                    console.error('Error al copiar el texto: ', err);
                });
            });
        });
    </script>

</body>
</html>